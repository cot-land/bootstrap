// Source text handling and position tracking.
//
// Maps to Go's cmd/compile/internal/syntax/source.go and cmd/internal/src/pos.go
// This is the target implementation for self-hosting.

module source;

// =============================================================================
// LANGUAGE FEATURES USED (Phase 1-7):
// =============================================================================
// 1. Module declaration and pub visibility (Phase 6)
// 2. Structs with fields
// 3. Const struct values
// 4. Optional types (?[]u32)
// 5. @min builtin for clamping
// 6. @intCast for integer conversions
// 7. Slice syntax (content[s..e])
// 8. Range iteration (for i in 0..n) (Phase 4)
// 9. Indexed iteration (for c, i in content) (Phase 4)
// 10. Null coalescing (??)
// 11. len() builtin
// 12. String interpolation
// 13. Array indexing
// =============================================================================

// ============================================================================
// Position
// ============================================================================

/// A position in source code (offset-based).
/// Compact representation - line/column computed on demand.
pub struct Pos {
    offset: u32,
}

/// Constant for zero position.
pub const zero: Pos = Pos{ .offset = 0 };

/// Advance a position by n bytes.
pub fn advance(self: Pos, n: u32) Pos {
    return Pos{ .offset = self.offset + n };
}

/// Check if two positions are equal.
pub fn equals(self: Pos, other: Pos) bool {
    return self.offset == other.offset;
}

/// Check if this position is before another.
pub fn isBefore(self: Pos, other: Pos) bool {
    return self.offset < other.offset;
}

/// Check if this position is after another.
pub fn isAfter(self: Pos, other: Pos) bool {
    return self.offset > other.offset;
}

// ============================================================================
// Span
// ============================================================================

/// A span in source code (start and end positions).
/// Used for AST nodes and error messages.
pub struct Span {
    start: Pos,
    end: Pos,
}

/// Create a span from start and end positions.
pub fn init(start: Pos, end: Pos) Span {
    return Span{ .start = start, .end = end };
}

/// Create a span from a single position (zero-length).
pub fn fromPos(pos: Pos) Span {
    return Span{ .start = pos, .end = pos };
}

/// Combine two spans (union).
pub fn combine(self: Span, other: Span) Span {
    var s = if self.start.offset < other.start.offset { self.start } else { other.start };
    var e = if self.end.offset > other.end.offset { self.end } else { other.end };
    return Span{ .start = s, .end = e };
}

/// Get the length of the span in bytes.
pub fn length(self: Span) u32 {
    return self.end.offset - self.start.offset;
}

/// Check if a position is within this span.
pub fn contains(self: Span, pos: Pos) bool {
    return pos.offset >= self.start.offset and pos.offset < self.end.offset;
}

// ============================================================================
// Location
// ============================================================================

/// Human-readable location (for error messages).
pub struct Location {
    line: u32,      // 1-based
    column: u32,    // 1-based
    offset: u32,    // 0-based byte offset
}

/// Format location as "line:column".
pub fn format(self: Location) string {
    return "${self.line}:${self.column}";
}

// ============================================================================
// Source
// ============================================================================

/// Source holds the content of a source file.
pub struct Source {
    filename: string,       // File name (for error messages)
    content: string,        // Source content (UTF-8)
    line_offsets: ?[]u32,   // Byte offsets of line starts (computed lazily)
}

/// Initialize a source from content.
/// Note: cot uses ARC, so no explicit allocator needed.
pub fn sourceInit(filename: string, content: string) Source {
    return Source{
        .filename = filename,
        .content = content,
        .line_offsets = null,
    };
}

/// Get the byte at a position, or null if past end.
pub fn at(self: *Source, pos: Pos) ?byte {
    if pos.offset >= len(self.content) {
        return null;
    }
    return self.content[pos.offset];
}

/// Get a slice of source content between two positions.
pub fn slice(self: *Source, start: Pos, end: Pos) string {
    var s = @min(start.offset, len(self.content));
    var e = @min(end.offset, len(self.content));
    return self.content[s..e];
}

/// Get the text for a span.
pub fn spanText(self: *Source, span: Span) string {
    return self.slice(span.start, span.end);
}

/// Convert a position to a human-readable location.
pub fn location(self: *Source, pos: Pos) Location {
    self.ensureLineOffsets();

    var offsets = self.line_offsets ?? return Location{
        .line = 1,
        .column = 1,
        .offset = pos.offset,
    };
    var offset = pos.offset;

    // Binary search for the line containing this offset
    var line: u32 = 0;
    var lo: int = 0;
    var hi: int = len(offsets);

    while lo < hi {
        var mid = lo + (hi - lo) / 2;
        if offsets[mid] <= offset {
            line = @intCast(u32, mid);
            lo = mid + 1;
        } else {
            hi = mid;
        }
    }

    var line_start = offsets[line];
    var column = offset - line_start;

    return Location{
        .line = line + 1,       // 1-based
        .column = column + 1,   // 1-based
        .offset = offset,
    };
}

/// Compute line offsets if not already done.
pub fn ensureLineOffsets(self: *Source) {
    if self.line_offsets != null {
        return;
    }

    // Count newlines first using indexed iteration
    var count: int = 1;  // Line 1 starts at offset 0
    for c in self.content {
        if c == '\n' {
            count += 1;
        }
    }

    // Allocate and fill
    var offsets = new [count]u32;
    offsets[0] = 0;
    var idx: int = 1;

    // Use indexed iteration (Phase 4)
    for c, i in self.content {
        if c == '\n' {
            offsets[idx] = @intCast(u32, i + 1);
            idx += 1;
        }
    }

    self.line_offsets = offsets;
}

/// Get the line containing a position (for error context).
pub fn getLine(self: *Source, pos: Pos) string {
    self.ensureLineOffsets();
    var loc = self.location(pos);

    var offsets = self.line_offsets ?? return "";

    var line_idx = loc.line - 1;
    var start = offsets[line_idx];

    // Find end of line
    var end_offset = start;
    while end_offset < len(self.content) and self.content[end_offset] != '\n' {
        end_offset += 1;
    }

    return self.content[start..end_offset];
}

/// Get the number of lines in the source.
pub fn lineCount(self: *Source) int {
    self.ensureLineOffsets();
    var offsets = self.line_offsets ?? return 1;
    return len(offsets);
}

/// Get a specific line by number (1-based).
pub fn getLineByNumber(self: *Source, line_num: u32) ?string {
    self.ensureLineOffsets();
    var offsets = self.line_offsets ?? return null;

    if line_num == 0 or line_num > len(offsets) {
        return null;
    }

    var line_idx = line_num - 1;
    var start = offsets[line_idx];

    // Find end of line
    var end_offset = start;
    while end_offset < len(self.content) and self.content[end_offset] != '\n' {
        end_offset += 1;
    }

    return self.content[start..end_offset];
}

/// Format an error message with source location.
pub fn formatError(self: *Source, pos: Pos, msg: string) {
    var loc = self.location(pos);
    println("${self.filename}:${loc.line}:${loc.column}: error: ${msg}");
}

/// Check if the source is empty.
pub fn isEmpty(self: *Source) bool {
    return len(self.content) == 0;
}

/// Get the total length of the source in bytes.
pub fn length(self: *Source) int {
    return len(self.content);
}
