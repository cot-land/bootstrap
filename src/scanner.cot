// Lexical scanner for cot.
//
// Maps to Go's cmd/compile/internal/syntax/scanner.go
// This is the target implementation for self-hosting.

module scanner;

import token;
import source;
import errors;

// =============================================================================
// LANGUAGE FEATURES USED (Phase 1-7):
// =============================================================================
// 1. Module declaration and pub visibility (Phase 6)
// 2. Imports (Phase 6)
// 3. Pointer fields in structs (err: ?*ErrorReporter)
// 4. Optional unwrap with .? operator (self.ch.?)
// 5. If/while with capture (if self.ch |c| { }, while self.ch |c| { })
// 6. Optional chaining (?.) for error reporting (Phase 5)
// 7. Methods on structs (fn init(src: *Source) Scanner)
// 8. Switch expressions
// 9. Null coalescing (??) for keyword lookup
// =============================================================================

// ============================================================================
// Token Info
// ============================================================================

/// A scanned token with position and text.
pub struct TokenInfo {
    tok: Token,
    span: Span,
    text: string,  // For identifiers and literals; empty for keywords/operators
}

// ============================================================================
// Scanner
// ============================================================================

/// Scanner tokenizes source code.
pub struct Scanner {
    src: *Source,
    pos: Pos,
    ch: ?byte,              // Current character (or null if at end)
    err: ?*ErrorReporter,   // Error reporter (optional)
    in_interp_string: bool, // Track if we're inside an interpolated string (after seeing ${ )
    interp_brace_depth: u32, // Track brace depth for nested expressions in interpolated strings
}

/// Initialize scanner with source.
pub fn init(src: *Source) Scanner {
    return initWithErrors(src, null);
}

/// Initialize scanner with source and error reporter.
pub fn initWithErrors(src: *Source, err: ?*ErrorReporter) Scanner {
    var s = Scanner{
        .src = src,
        .pos = Pos.zero,
        .ch = null,
        .err = err,
        .in_interp_string = false,
        .interp_brace_depth = 0,
    };
    s.ch = src.at(s.pos);
    return s;
}

// ============================================================================
// Error reporting (using optional chaining - Phase 5)
// ============================================================================

/// Report an error at a position using optional chaining.
fn errorAt(self: *Scanner, pos: Pos, code: ErrorCode, msg: string) {
    // Phase 5: Optional chaining - if err is null, this is a no-op
    self.err?.errorAtWithCode(pos, code, msg);
}

// ============================================================================
// Main scanning interface
// ============================================================================

/// Scan and return the next token.
pub fn next(self: *Scanner) TokenInfo {
    self.skipWhitespaceAndComments();

    var start = self.pos;

    // Check for end of file
    if self.ch == null {
        return TokenInfo{
            .tok = .eof,
            .span = Span.fromPos(start),
            .text = "",
        };
    }

    var c = self.ch.?;

    // Identifier or keyword
    if isAlpha(c) or c == '_' {
        return self.scanIdentifier(start);
    }

    // Number
    if isDigit(c) {
        return self.scanNumber(start);
    }

    // String literal
    if c == '"' {
        return self.scanString(start);
    }

    // Character literal
    if c == '\'' {
        return self.scanChar(start);
    }

    // Operators and delimiters
    return self.scanOperator(start);
}

/// Check if scanner is at end of file.
pub fn isEof(self: *Scanner) bool {
    return self.ch == null;
}

// ============================================================================
// Whitespace and comments
// ============================================================================

/// Skip whitespace and comments.
fn skipWhitespaceAndComments(self: *Scanner) {
    while self.ch |c| {
        if c == ' ' or c == '\t' or c == '\n' or c == '\r' {
            self.advance();
        } else if c == '/' {
            if self.peek(1) == '/' {
                self.skipLineComment();
            } else if self.peek(1) == '*' {
                self.skipBlockComment();
            } else {
                break;
            }
        } else {
            break;
        }
    }
}

fn skipLineComment(self: *Scanner) {
    // Skip //
    self.advance();
    self.advance();
    // Skip until newline or EOF
    while self.ch |c| {
        if c == '\n' {
            self.advance();
            break;
        }
        self.advance();
    }
}

fn skipBlockComment(self: *Scanner) {
    var start = self.pos;
    // Skip /*
    self.advance();
    self.advance();
    // Skip until */
    while self.ch != null {
        if self.ch == '*' and self.peek(1) == '/' {
            self.advance();
            self.advance();
            return;
        }
        self.advance();
    }
    // Unterminated block comment
    self.errorAt(start, .E100, "unterminated block comment");
}

// ============================================================================
// Identifier scanning
// ============================================================================

/// Scan an identifier or keyword.
fn scanIdentifier(self: *Scanner, start: Pos) TokenInfo {
    while self.ch |c| {
        if isAlphaNumeric(c) or c == '_' {
            self.advance();
        } else {
            break;
        }
    }

    var text = self.src.content[start.offset..self.pos.offset];

    // Check if it's a keyword using null coalescing
    var tok = token.lookupKeyword(text) ?? .identifier;

    return TokenInfo{
        .tok = tok,
        .span = Span.init(start, self.pos),
        .text = if tok == .identifier { text } else { "" },
    };
}

// ============================================================================
// Number scanning
// ============================================================================

/// Scan a number literal (integer or float).
fn scanNumber(self: *Scanner, start: Pos) TokenInfo {
    var is_float = false;

    // Handle hex, octal, binary prefixes
    if self.ch == '0' {
        self.advance();
        if self.ch |c| {
            if c == 'x' or c == 'X' {
                self.advance();
                self.scanHexDigits();
                return self.makeNumberToken(start, false);
            } else if c == 'o' or c == 'O' {
                self.advance();
                self.scanOctalDigits();
                return self.makeNumberToken(start, false);
            } else if c == 'b' or c == 'B' {
                self.advance();
                self.scanBinaryDigits();
                return self.makeNumberToken(start, false);
            }
        }
    }

    // Decimal digits
    self.scanDecimalDigits();

    // Fractional part - check for .. range operator
    if self.ch == '.' and self.peek(1) != '.' {
        is_float = true;
        self.advance();
        self.scanDecimalDigits();
    }

    // Exponent
    if self.ch |c| {
        if c == 'e' or c == 'E' {
            is_float = true;
            self.advance();
            if self.ch == '+' or self.ch == '-' {
                self.advance();
            }
            self.scanDecimalDigits();
        }
    }

    return self.makeNumberToken(start, is_float);
}

fn makeNumberToken(self: *Scanner, start: Pos, is_float: bool) TokenInfo {
    var text = self.src.content[start.offset..self.pos.offset];
    return TokenInfo{
        .tok = if is_float { .float_literal } else { .int_literal },
        .span = Span.init(start, self.pos),
        .text = text,
    };
}

fn scanDecimalDigits(self: *Scanner) {
    while self.ch |c| {
        if isDigit(c) or c == '_' {
            self.advance();
        } else {
            break;
        }
    }
}

fn scanHexDigits(self: *Scanner) {
    while self.ch |c| {
        if isHexDigit(c) or c == '_' {
            self.advance();
        } else {
            break;
        }
    }
}

fn scanOctalDigits(self: *Scanner) {
    while self.ch |c| {
        if (c >= '0' and c <= '7') or c == '_' {
            self.advance();
        } else {
            break;
        }
    }
}

fn scanBinaryDigits(self: *Scanner) {
    while self.ch |c| {
        if c == '0' or c == '1' or c == '_' {
            self.advance();
        } else {
            break;
        }
    }
}

// ============================================================================
// String scanning
// ============================================================================

/// Scan a string literal (may be interpolated).
fn scanString(self: *Scanner, start: Pos) TokenInfo {
    self.advance();  // consume opening "

    var terminated = false;
    var found_interp = false;
    while self.ch |c| {
        if c == '"' {
            self.advance();
            terminated = true;
            break;
        } else if c == '\\' {
            self.advance();  // skip backslash
            if self.ch != null {
                self.advance();  // skip escaped char
            }
        } else if c == '$' {
            // Check for ${ interpolation
            var next_ch = self.src.at(self.pos.advance(1));
            if next_ch != null and next_ch.? == '{' {
                self.advance();  // consume $
                self.advance();  // consume {
                found_interp = true;
                self.in_interp_string = true;
                self.interp_brace_depth = 1;
                break;
            } else {
                self.advance();  // just a regular $
            }
        } else if c == '\n' {
            // Unterminated string - newline before closing quote
            break;
        } else {
            self.advance();
        }
    }

    if not terminated and not found_interp {
        self.errorAt(start, .E100, "string literal not terminated");
    }

    var text = self.src.content[start.offset..self.pos.offset];
    if found_interp {
        return TokenInfo{
            .tok = .string_interp_start,
            .span = Span.init(start, self.pos),
            .text = text,
        };
    }
    return TokenInfo{
        .tok = .string_literal,
        .span = Span.init(start, self.pos),
        .text = text,
    };
}

/// Continue scanning an interpolated string after an expression.
/// Called when we see } and are in interpolated string mode.
fn scanStringContinuation(self: *Scanner, start: Pos) TokenInfo {
    var terminated = false;
    var found_interp = false;

    while self.ch |c| {
        if c == '"' {
            self.advance();
            terminated = true;
            self.in_interp_string = false;
            break;
        } else if c == '\\' {
            self.advance();  // skip backslash
            if self.ch != null {
                self.advance();  // skip escaped char
            }
        } else if c == '$' {
            // Check for ${ interpolation
            var next_ch = self.src.at(self.pos.advance(1));
            if next_ch != null and next_ch.? == '{' {
                self.advance();  // consume $
                self.advance();  // consume {
                found_interp = true;
                self.interp_brace_depth = 1;
                break;
            } else {
                self.advance();  // just a regular $
            }
        } else if c == '\n' {
            // Unterminated string - newline before closing quote
            break;
        } else {
            self.advance();
        }
    }

    if not terminated and not found_interp {
        self.errorAt(start, .E100, "string literal not terminated");
    }

    var text = self.src.content[start.offset..self.pos.offset];
    if found_interp {
        return TokenInfo{
            .tok = .string_interp_mid,
            .span = Span.init(start, self.pos),
            .text = text,
        };
    }
    return TokenInfo{
        .tok = .string_interp_end,
        .span = Span.init(start, self.pos),
        .text = text,
    };
}

// ============================================================================
// Character literal scanning
// ============================================================================

/// Scan a character literal.
fn scanChar(self: *Scanner, start: Pos) TokenInfo {
    self.advance();  // consume opening '

    if self.ch == '\\' {
        self.advance();
        if self.ch != null {
            self.advance();
        }
    } else if self.ch != null and self.ch != '\'' {
        self.advance();
    }

    var terminated = false;
    if self.ch == '\'' {
        self.advance();
        terminated = true;
    }

    if not terminated {
        self.errorAt(start, .E101, "character literal not terminated");
    }

    var text = self.src.content[start.offset..self.pos.offset];
    return TokenInfo{
        .tok = .char_literal,
        .span = Span.init(start, self.pos),
        .text = text,
    };
}

// ============================================================================
// Operator scanning
// ============================================================================

/// Scan operators and delimiters.
fn scanOperator(self: *Scanner, start: Pos) TokenInfo {
    var c = self.ch.?;
    self.advance();

    // Handle braces specially when in interpolated string mode
    if c == '{' and self.in_interp_string {
        self.interp_brace_depth += 1;
        return TokenInfo{
            .tok = .lbrace,
            .span = Span.init(start, self.pos),
            .text = "",
        };
    }

    if c == '}' and self.in_interp_string {
        self.interp_brace_depth -= 1;
        if self.interp_brace_depth == 0 {
            // End of interpolated expression - continue scanning string
            return self.scanStringContinuation(start);
        }
        return TokenInfo{
            .tok = .rbrace,
            .span = Span.init(start, self.pos),
            .text = "",
        };
    }

    var tok = switch c {
        '(' => .lparen,
        ')' => .rparen,
        '[' => .lbracket,
        ']' => .rbracket,
        '{' => .lbrace,
        '}' => .rbrace,
        ',' => .comma,
        ';' => .semicolon,
        ':' => .colon,
        '~' => .tilde,
        '@' => .at,

        '+' => if self.ch == '=' {
            self.advance();
            .plus_equal
        } else if self.ch == '+' {
            self.advance();
            .plus_plus
        } else {
            .plus
        },

        '-' => if self.ch == '=' {
            self.advance();
            .minus_equal
        } else if self.ch == '>' {
            self.advance();
            .arrow
        } else {
            .minus
        },

        '*' => if self.ch == '=' {
            self.advance();
            .star_equal
        } else {
            .star
        },

        '/' => if self.ch == '=' {
            self.advance();
            .slash_equal
        } else {
            .slash
        },

        '%' => if self.ch == '=' {
            self.advance();
            .percent_equal
        } else {
            .percent
        },

        '&' => if self.ch == '=' {
            self.advance();
            .ampersand_equal
        } else {
            .ampersand
        },

        '|' => if self.ch == '=' {
            self.advance();
            .pipe_equal
        } else {
            .pipe
        },

        '^' => if self.ch == '=' {
            self.advance();
            .caret_equal
        } else {
            .caret
        },

        '=' => if self.ch == '=' {
            self.advance();
            .equal_equal
        } else if self.ch == '>' {
            self.advance();
            .fat_arrow
        } else {
            .equal
        },

        '!' => if self.ch == '=' {
            self.advance();
            .bang_equal
        } else {
            .bang
        },

        '<' => if self.ch == '=' {
            self.advance();
            .less_equal
        } else if self.ch == '<' {
            self.advance();
            .less_less
        } else {
            .less
        },

        '>' => if self.ch == '=' {
            self.advance();
            .greater_equal
        } else if self.ch == '>' {
            self.advance();
            .greater_greater
        } else {
            .greater
        },

        '.' => if self.ch == '.' {
            self.advance();
            .dot_dot
        } else if self.ch == '*' {
            self.advance();
            .dot_star
        } else if self.ch == '?' {
            self.advance();
            .dot_question
        } else {
            .dot
        },

        '?' => if self.ch == '?' {
            self.advance();
            .question_question
        } else if self.ch == '.' {
            self.advance();
            .question_dot
        } else {
            .question
        },

        else => .invalid,
    };

    if tok == .invalid {
        self.errorAt(start, .E104, "unexpected character");
    }

    return TokenInfo{
        .tok = tok,
        .span = Span.init(start, self.pos),
        .text = "",
    };
}

// ============================================================================
// Character movement
// ============================================================================

/// Advance to next character.
fn advance(self: *Scanner) {
    self.pos = self.pos.advance(1);
    self.ch = self.src.at(self.pos);
}

/// Peek ahead n characters.
fn peek(self: *Scanner, n: u32) ?byte {
    return self.src.at(self.pos.advance(n));
}

// ============================================================================
// Character classification helpers (could be string methods in Phase 3)
// ============================================================================

pub fn isAlpha(c: byte) bool {
    return (c >= 'a' and c <= 'z') or (c >= 'A' and c <= 'Z');
}

pub fn isDigit(c: byte) bool {
    return c >= '0' and c <= '9';
}

pub fn isHexDigit(c: byte) bool {
    return isDigit(c) or (c >= 'a' and c <= 'f') or (c >= 'A' and c <= 'F');
}

pub fn isAlphaNumeric(c: byte) bool {
    return isAlpha(c) or isDigit(c);
}

pub fn isWhitespace(c: byte) bool {
    return c == ' ' or c == '\t' or c == '\r' or c == '\n';
}
