// Type checker for cot.
//
// Maps to Go's cmd/compile/internal/types2/
// - checker.go (Checker struct, main entry points)
// - resolver.go (name resolution)
// - decl.go (declaration checking)
// - expr.go (expression type checking)
// - stmt.go (statement checking)

// =============================================================================
// LANGUAGE FEATURES USED:
// =============================================================================
// 1. Enums (SymbolKind)
// 2. Structs with optional fields
// 3. Methods on structs (fn init(self: ...) ...)
// 4. Switch expressions with payload capture
// 5. Optional types and if-capture (if x |val| {})
// 6. Map<K, V> for symbol tables
// 7. String interpolation
// 8. Error handling (!void, try)
// =============================================================================

import "ast"
import "types"
import "errors"
import "source"

// ============================================================================
// Symbol
// ============================================================================

// What kind of symbol this is.
enum SymbolKind: u8 {
    variable,
    constant,
    function,
    type_name,
    parameter,
}

// A symbol in a scope (variable, function, type, etc.)
struct Symbol {
    name: string,
    kind: SymbolKind,
    type_idx: TypeIndex,
    node: NodeIndex,        // AST node index (for functions, structs, etc.)
    mutable: bool,          // Is this symbol mutable? (var vs const)
}

fn init(name: string, kind: SymbolKind, type_idx: TypeIndex, node: NodeIndex, mutable: bool) Symbol {
    return Symbol{
        .name = name,
        .kind = kind,
        .type_idx = type_idx,
        .node = node,
        .mutable = mutable,
    }
}

// ============================================================================
// Scope
// ============================================================================

// Lexical scope for name resolution.
// Scopes form a tree with parent pointers.
struct Scope {
    parent: ?*Scope,
    symbols: Map<string, Symbol>,
}

fn init(parent: ?*Scope) Scope {
    return Scope{
        .parent = parent,
        .symbols = new Map<string, Symbol>,
    }
}

// Define a symbol in this scope.
fn define(self: *Scope, sym: Symbol) !void {
    self.symbols.set(sym.name, sym)
}

// Look up a symbol in this scope only.
fn lookupLocal(self: *Scope, name: string) ?Symbol {
    return self.symbols.get(name)
}

// Look up a symbol in this scope or any parent scope.
fn lookup(self: *Scope, name: string) ?Symbol {
    if self.symbols.get(name) |sym| {
        return sym
    }
    if self.parent |p| {
        return p.lookup(name)
    }
    return null
}

// Check if a name is already defined in this scope (not parent).
fn isDefined(self: *Scope, name: string) bool {
    return self.symbols.has(name)
}

// ============================================================================
// Checker
// ============================================================================

// Type checker state.
struct Checker {
    types: *TypeRegistry,       // Type registry for type interning and lookup
    scope: *Scope,              // Current scope
    err: *ErrorReporter,        // Error reporter
    tree: *Ast,                 // AST being checked
    expr_types: Map<NodeIndex, TypeIndex>,  // Expression type cache
    current_return_type: TypeIndex,         // Current function return type
    in_loop: bool,              // Are we inside a loop? (for break/continue)
}

fn init(tree: *Ast, type_reg: *TypeRegistry, reporter: *ErrorReporter, global_scope: *Scope) Checker {
    return Checker{
        .types = type_reg,
        .scope = global_scope,
        .err = reporter,
        .tree = tree,
        .expr_types = new Map<NodeIndex, TypeIndex>,
        .current_return_type = TypeRegistry.VOID,
        .in_loop = false,
    }
}

// ========================================================================
// File checking
// ========================================================================

// Type check an entire file.
fn checkFile(self: *Checker) !void {
    var file = self.tree.file ?? return

    // First pass: collect all top-level declarations
    for decl_idx in file.decls {
        try self.collectDecl(decl_idx)
    }

    // Second pass: check all declarations
    for decl_idx in file.decls {
        try self.checkDecl(decl_idx)
    }
}

// Collect a declaration (add to scope without checking body).
fn collectDecl(self: *Checker, idx: NodeIndex) !void {
    var decl = self.tree.getDecl(idx) ?? return

    switch decl {
        .fn_decl |f| => {
            if self.scope.isDefined(f.name) {
                self.errRedefined(f.span.start, f.name)
                return
            }
            // Build function type
            var func_type = try self.buildFuncType(f.params, f.return_type)
            try self.scope.define(Symbol.init(
                f.name,
                .function,
                func_type,
                idx,
                false,
            ))
        },
        .var_decl |v| => {
            if self.scope.isDefined(v.name) {
                self.errRedefined(v.span.start, v.name)
                return
            }
            // Type will be determined in checkDecl
            try self.scope.define(Symbol.init(
                v.name,
                .variable,
                invalid_type,
                idx,
                true,
            ))
        },
        .const_decl |c| => {
            if self.scope.isDefined(c.name) {
                self.errRedefined(c.span.start, c.name)
                return
            }
            try self.scope.define(Symbol.init(
                c.name,
                .constant,
                invalid_type,
                idx,
                false,
            ))
        },
        .struct_decl |s| => {
            if self.scope.isDefined(s.name) {
                self.errRedefined(s.span.start, s.name)
                return
            }
            // Build struct type
            var struct_type = try self.buildStructType(s.name, s.fields)
            try self.scope.define(Symbol.init(
                s.name,
                .type_name,
                struct_type,
                idx,
                false,
            ))
        },
        .enum_decl |e| => {
            if self.scope.isDefined(e.name) {
                self.errRedefined(e.span.start, e.name)
                return
            }
            // TODO: build enum type
            try self.scope.define(Symbol.init(
                e.name,
                .type_name,
                invalid_type,
                idx,
                false,
            ))
        },
        .bad_decl => {},
    }
}

// ========================================================================
// Declaration checking
// ========================================================================

// Check a declaration.
fn checkDecl(self: *Checker, idx: NodeIndex) !void {
    var decl = self.tree.getDecl(idx) ?? return

    switch decl {
        .fn_decl |f| => try self.checkFnDecl(f, idx),
        .var_decl |v| => try self.checkVarDecl(v, idx),
        .const_decl |c| => try self.checkConstDecl(c, idx),
        .struct_decl => {},  // Already processed in collectDecl
        .enum_decl => {},    // TODO
        .bad_decl => {},
    }
}

// Check function declaration.
fn checkFnDecl(self: *Checker, f: FnDecl, idx: NodeIndex) !void {
    // Get the function type we built earlier
    var sym = self.scope.lookup(f.name) ?? return
    var func_type = self.types.get(sym.type_idx)
    var return_type = switch func_type {
        .func |ft| => ft.return_type,
        else => TypeRegistry.VOID,
    }

    // Create new scope for function body
    var func_scope = Scope.init(self.scope)

    // Add parameters to function scope
    for param in f.params {
        var param_type = try self.resolveTypeExpr(param.type_expr)
        try func_scope.define(Symbol.init(
            param.name,
            .parameter,
            param_type,
            idx,
            false,  // parameters are immutable by default
        ))
    }

    // Save state
    var old_scope = self.scope
    var old_return = self.current_return_type

    // Set up for function body
    self.scope = &func_scope
    self.current_return_type = return_type

    // Check body if present
    if f.body |body_idx| {
        try self.checkBlockExpr(body_idx)
    }

    // Restore state
    self.scope = old_scope
    self.current_return_type = old_return
}

// Check variable declaration.
fn checkVarDecl(self: *Checker, v: VarDecl, idx: NodeIndex) !void {
    var var_type: TypeIndex = invalid_type

    // Get explicit type if present
    if v.type_expr |type_idx| {
        var_type = try self.resolveTypeExpr(type_idx)
    }

    // Check initializer if present
    if v.value |val_idx| {
        var val_type = try self.checkExpr(val_idx)

        if var_type == invalid_type {
            // Infer type from initializer
            var_type = self.materializeType(val_type)
        } else {
            // Check that value is assignable to declared type
            if not self.isAssignable(val_type, var_type) {
                self.errTypeMismatch(v.span.start, var_type, val_type)
            }
        }
    }

    // Update symbol with resolved type
    if self.scope.lookupLocal(v.name) |_| {
        try self.scope.define(Symbol.init(
            v.name,
            .variable,
            var_type,
            idx,
            true,
        ))
    }
}

// Check const declaration.
fn checkConstDecl(self: *Checker, c: ConstDecl, idx: NodeIndex) !void {
    var const_type: TypeIndex = invalid_type

    // Get explicit type if present
    if c.type_expr |type_idx| {
        const_type = try self.resolveTypeExpr(type_idx)
    }

    // Check initializer (required for const)
    var val_type = try self.checkExpr(c.value)

    if const_type == invalid_type {
        const_type = self.materializeType(val_type)
    } else {
        if not self.isAssignable(val_type, const_type) {
            self.errTypeMismatch(c.span.start, const_type, val_type)
        }
    }

    // Update symbol with resolved type
    if self.scope.lookupLocal(c.name) |_| {
        try self.scope.define(Symbol.init(
            c.name,
            .constant,
            const_type,
            idx,
            false,
        ))
    }
}

// ========================================================================
// Expression checking
// ========================================================================

// Check an expression and return its type.
fn checkExpr(self: *Checker, idx: NodeIndex) !TypeIndex {
    // Check cache first
    if self.expr_types.get(idx) |t| {
        return t
    }

    var result = try self.checkExprInner(idx)
    self.expr_types.set(idx, result)
    return result
}

fn checkExprInner(self: *Checker, idx: NodeIndex) !TypeIndex {
    var expr = self.tree.getExpr(idx) ?? return invalid_type

    return switch expr {
        .identifier |id| => self.checkIdentifier(id),
        .literal |lit| => self.checkLiteral(lit),
        .binary |bin| => try self.checkBinary(bin),
        .unary |un| => try self.checkUnary(un),
        .call |c| => try self.checkCall(c),
        .index |i| => try self.checkIndex(i),
        .field_access |f| => try self.checkFieldAccess(f),
        .array_literal |al| => try self.checkArrayLiteral(al),
        .paren |p| => try self.checkExpr(p.inner),
        .if_expr |ie| => try self.checkIfExpr(ie),
        .block |b| => try self.checkBlock(b),
        .struct_init |si| => try self.checkStructInit(si),
        .type_expr => invalid_type,  // Types are not values
        .bad_expr => invalid_type,
    }
}

// Check identifier expression.
fn checkIdentifier(self: *Checker, id: Identifier) TypeIndex {
    if self.scope.lookup(id.name) |sym| {
        return sym.type_idx
    }
    self.errUndefined(id.span.start, id.name)
    return invalid_type
}

// Check literal expression.
fn checkLiteral(self: *Checker, lit: Literal) TypeIndex {
    return switch lit.kind {
        .int => TypeRegistry.INT,
        .float => TypeRegistry.FLOAT,
        .string => TypeRegistry.STRING,
        .char => TypeRegistry.U8,  // char is u8
        .true_lit, .false_lit => TypeRegistry.BOOL,
        .null_lit => invalid_type,  // null needs context
    }
}

// Check binary expression.
fn checkBinary(self: *Checker, bin: Binary) !TypeIndex {
    var left_type = try self.checkExpr(bin.left)
    var right_type = try self.checkExpr(bin.right)

    var left = self.types.get(left_type)
    var right = self.types.get(right_type)

    // Arithmetic operators: +, -, *, /, %
    switch bin.op {
        .plus, .minus, .star, .slash, .percent => {
            // Both operands must be numeric
            if not isNumeric(left) or not isNumeric(right) {
                self.errInvalidOp(bin.span.start, "arithmetic", left_type, right_type)
                return invalid_type
            }
            // Result is the common type (simplified: use left type)
            return left_type
        },
        // Comparison operators: ==, !=, <, <=, >, >=
        .equal_equal, .bang_equal, .less, .less_equal, .greater, .greater_equal => {
            // Both operands must be comparable
            if not self.isComparable(left_type, right_type) {
                self.errInvalidOp(bin.span.start, "comparison", left_type, right_type)
                return invalid_type
            }
            return TypeRegistry.BOOL
        },
        // Logical operators: and, or
        .kw_and, .kw_or => {
            // Both operands must be bool
            if not isBool(left) or not isBool(right) {
                self.errInvalidOp(bin.span.start, "logical", left_type, right_type)
                return invalid_type
            }
            return TypeRegistry.BOOL
        },
        // Bitwise operators: &, |, ^
        .ampersand, .pipe, .caret => {
            // Both operands must be integer
            if not isInteger(left) or not isInteger(right) {
                self.errInvalidOp(bin.span.start, "bitwise", left_type, right_type)
                return invalid_type
            }
            return left_type
        },
        else => return invalid_type,
    }
}

// Check unary expression.
fn checkUnary(self: *Checker, un: Unary) !TypeIndex {
    var operand_type = try self.checkExpr(un.operand)
    var operand = self.types.get(operand_type)

    switch un.op {
        .minus => {
            if not isNumeric(operand) {
                self.err.errorWithCode(un.span.start, .E303, "unary '-' requires numeric operand")
                return invalid_type
            }
            return operand_type
        },
        .bang, .kw_not => {
            if not isBool(operand) {
                self.err.errorWithCode(un.span.start, .E303, "unary '!' requires bool operand")
                return invalid_type
            }
            return TypeRegistry.BOOL
        },
        else => return invalid_type,
    }
}

// Check function call.
fn checkCall(self: *Checker, c: Call) !TypeIndex {
    // Check for builtin functions first
    if self.tree.getExpr(c.callee) |callee_expr| {
        if callee_expr == .identifier {
            var name = callee_expr.identifier.name
            if name == "len" {
                return self.checkBuiltinLen(c)
            }
        }
    }

    var callee_type = try self.checkExpr(c.callee)
    var callee = self.types.get(callee_type)

    switch callee {
        .func |ft| => {
            // Check argument count
            if len(c.args) != len(ft.params) {
                self.err.errorWithCode(c.span.start, .E300, "wrong number of arguments")
                return invalid_type
            }

            // Check argument types
            var i: u32 = 0
            for arg_idx in c.args {
                var arg_type = try self.checkExpr(arg_idx)
                var param_type = ft.params[i].type_idx
                if not self.isAssignable(arg_type, param_type) {
                    self.errTypeMismatch(c.span.start, param_type, arg_type)
                }
                i += 1
            }

            return ft.return_type
        },
        else => {
            self.err.errorWithCode(c.span.start, .E303, "cannot call non-function")
            return invalid_type
        },
    }
}

// Check builtin len() function.
fn checkBuiltinLen(self: *Checker, c: Call) !TypeIndex {
    // len() takes exactly one argument
    if len(c.args) != 1 {
        self.err.errorWithCode(c.span.start, .E300, "len() expects exactly one argument")
        return invalid_type
    }

    var arg_type = try self.checkExpr(c.args[0])
    var arg = self.types.get(arg_type)

    // len() works on strings, arrays, and slices
    switch arg {
        .basic |k| => {
            if k == .string_type {
                return TypeRegistry.INT
            }
        },
        .array, .slice => {
            return TypeRegistry.INT
        },
        else => {},
    }

    self.err.errorWithCode(c.span.start, .E300, "len() argument must be string, array, or slice")
    return invalid_type
}

// Check index expression.
fn checkIndex(self: *Checker, i: Index) !TypeIndex {
    var base_type = try self.checkExpr(i.base)
    var index_type = try self.checkExpr(i.index)
    var base = self.types.get(base_type)

    // Index must be integer
    var index = self.types.get(index_type)
    if not isInteger(index) {
        self.err.errorWithCode(i.span.start, .E300, "index must be integer")
        return invalid_type
    }

    // Check indexable types
    return switch base {
        .array |a| => a.elem,
        .slice |s| => s.elem,
        .basic |k| => if k == .string_type { TypeRegistry.U8 } else { invalid_type },
        else => {
            self.err.errorWithCode(i.span.start, .E303, "cannot index this type")
            return invalid_type
        },
    }
}

// Check field access.
fn checkFieldAccess(self: *Checker, f: FieldAccess) !TypeIndex {
    var base_type = try self.checkExpr(f.base)
    var base = self.types.get(base_type)

    // Handle struct field access
    switch base {
        .struct_type |st| => {
            for field in st.fields {
                if field.name == f.field {
                    return field.type_idx
                }
            }
            self.errUndefined(f.span.start, f.field)
            return invalid_type
        },
        .pointer |ptr| => {
            // Auto-deref for field access
            var elem = self.types.get(ptr.elem)
            switch elem {
                .struct_type |st| => {
                    for field in st.fields {
                        if field.name == f.field {
                            return field.type_idx
                        }
                    }
                    self.errUndefined(f.span.start, f.field)
                    return invalid_type
                },
                else => {},
            }
            self.err.errorWithCode(f.span.start, .E303, "cannot access field on this type")
            return invalid_type
        },
        else => {
            self.err.errorWithCode(f.span.start, .E303, "cannot access field on this type")
            return invalid_type
        },
    }
}

// Check struct initialization: Point{ .x = 10, .y = 20 }
fn checkStructInit(self: *Checker, si: StructInit) !TypeIndex {
    // Look up the struct type
    var sym = self.scope.lookup(si.type_name) ?? {
        self.errUndefined(si.span.start, si.type_name)
        return invalid_type
    }

    var struct_type = self.types.get(sym.type_idx)
    switch struct_type {
        .struct_type |st| => {
            // Check each field initializer
            for field_init in si.fields {
                // Find the field in the struct type
                var found = false
                for struct_field in st.fields {
                    if struct_field.name == field_init.name {
                        found = true
                        // Check the value type matches the field type
                        var value_type = try self.checkExpr(field_init.value)
                        if not self.types.equal(value_type, struct_field.type_idx) {
                            self.err.errorWithCode(field_init.span.start, .E300, "type mismatch in field initializer")
                        }
                        break
                    }
                }
                if not found {
                    self.err.errorWithCode(field_init.span.start, .E301, "unknown field in struct initializer")
                }
            }
            return sym.type_idx
        },
        else => {
            self.err.errorWithCode(si.span.start, .E300, "not a struct type")
            return invalid_type
        },
    }
}

// Check array literal: [1, 2, 3]
fn checkArrayLiteral(self: *Checker, al: ArrayLiteral) !TypeIndex {
    if len(al.elements) == 0 {
        self.err.errorWithCode(al.span.start, .E300, "cannot infer type of empty array literal")
        return invalid_type
    }

    // Get type of first element
    var first_type = try self.checkExpr(al.elements[0])
    if first_type == invalid_type {
        return invalid_type
    }

    // Check all other elements have the same type
    var i: u32 = 1
    while i < len(al.elements) {
        var elem_type = try self.checkExpr(al.elements[i])
        if not self.types.equal(first_type, elem_type) {
            self.err.errorWithCode(al.span.start, .E300, "array elements must have same type")
            return invalid_type
        }
        i += 1
    }

    // Create array type with inferred element type and length
    return self.types.makeArray(first_type, len(al.elements))
}

// Check if expression.
fn checkIfExpr(self: *Checker, ie: IfExpr) !TypeIndex {
    var cond_type = try self.checkExpr(ie.condition)
    var cond = self.types.get(cond_type)

    if not isBool(cond) {
        self.err.errorWithCode(ie.span.start, .E300, "condition must be bool")
    }

    var then_type = try self.checkExpr(ie.then_branch)

    if ie.else_branch |else_idx| {
        var else_type = try self.checkExpr(else_idx)
        // Both branches must have same type
        if not self.types.equal(then_type, else_type) {
            self.err.errorWithCode(ie.span.start, .E300, "if branches have different types")
            return invalid_type
        }
        return then_type
    }

    // If without else has void type
    return TypeRegistry.VOID
}

// Check block expression.
fn checkBlock(self: *Checker, b: Block) !TypeIndex {
    // Create new scope for block
    var block_scope = Scope.init(self.scope)

    var old_scope = self.scope
    self.scope = &block_scope

    // Check statements
    for stmt_idx in b.stmts {
        try self.checkStmt(stmt_idx)
    }

    self.scope = old_scope

    // Block value is the final expression, or void
    if b.expr != null_node {
        return try self.checkExpr(b.expr)
    }
    return TypeRegistry.VOID
}

// Check block expression (from function body).
fn checkBlockExpr(self: *Checker, idx: NodeIndex) !void {
    var node = self.tree.getNode(idx)
    switch node {
        .expr |e| => switch e {
            .block |b| => {
                _ = try self.checkBlock(b)
            },
            else => {},
        },
        else => {},
    }
}

// ========================================================================
// Statement checking
// ========================================================================

// Check a statement.
fn checkStmt(self: *Checker, idx: NodeIndex) !void {
    var stmt = self.tree.getStmt(idx) ?? return

    switch stmt {
        .expr_stmt |es| => {
            _ = try self.checkExpr(es.expr)
        },
        .return_stmt |rs| => try self.checkReturn(rs),
        .var_stmt |vs| => try self.checkVarStmt(vs, idx),
        .assign_stmt |as_stmt| => try self.checkAssign(as_stmt),
        .if_stmt |is| => try self.checkIfStmt(is),
        .while_stmt |ws| => try self.checkWhileStmt(ws),
        .for_stmt |fs| => try self.checkForStmt(fs),
        .block_stmt |bs| => try self.checkBlockStmt(bs),
        .break_stmt |bs| => {
            if not self.in_loop {
                self.err.errorWithCode(bs.span.start, .E303, "break outside of loop")
            }
        },
        .continue_stmt |cs| => {
            if not self.in_loop {
                self.err.errorWithCode(cs.span.start, .E303, "continue outside of loop")
            }
        },
        .bad_stmt => {},
    }
}

// Check return statement.
fn checkReturn(self: *Checker, rs: ReturnStmt) !void {
    if rs.value |val_idx| {
        var val_type = try self.checkExpr(val_idx)
        if self.current_return_type == TypeRegistry.VOID {
            self.err.errorWithCode(rs.span.start, .E300, "void function should not return a value")
        } else if not self.isAssignable(val_type, self.current_return_type) {
            self.errTypeMismatch(rs.span.start, self.current_return_type, val_type)
        }
    } else {
        if self.current_return_type != TypeRegistry.VOID {
            self.err.errorWithCode(rs.span.start, .E300, "non-void function must return a value")
        }
    }
}

// Check var statement (local variable).
fn checkVarStmt(self: *Checker, vs: VarStmt, idx: NodeIndex) !void {
    if self.scope.isDefined(vs.name) {
        self.errRedefined(vs.span.start, vs.name)
        return
    }

    var var_type: TypeIndex = invalid_type

    if vs.type_expr |type_idx| {
        var_type = try self.resolveTypeExpr(type_idx)
    }

    if vs.value |val_idx| {
        var val_type = try self.checkExpr(val_idx)
        if var_type == invalid_type {
            var_type = self.materializeType(val_type)
        } else if not self.isAssignable(val_type, var_type) {
            self.errTypeMismatch(vs.span.start, var_type, val_type)
        }
    }

    try self.scope.define(Symbol.init(
        vs.name,
        if vs.is_const { .constant } else { .variable },
        var_type,
        idx,
        not vs.is_const,
    ))
}

// Check assignment statement.
fn checkAssign(self: *Checker, as_stmt: AssignStmt) !void {
    var target_type = try self.checkExpr(as_stmt.target)
    var value_type = try self.checkExpr(as_stmt.value)

    // Check target is assignable (lvalue)
    var target = self.tree.getExpr(as_stmt.target) ?? return
    switch target {
        .identifier |id| => {
            if self.scope.lookup(id.name) |sym| {
                if not sym.mutable {
                    self.err.errorWithCode(as_stmt.span.start, .E303, "cannot assign to constant")
                    return
                }
            }
        },
        .index, .field_access => {},  // These are valid lvalues
        else => {
            self.err.errorWithCode(as_stmt.span.start, .E303, "invalid assignment target")
            return
        },
    }

    if not self.isAssignable(value_type, target_type) {
        self.errTypeMismatch(as_stmt.span.start, target_type, value_type)
    }
}

// Check if statement.
fn checkIfStmt(self: *Checker, is: IfStmt) !void {
    var cond_type = try self.checkExpr(is.condition)
    var cond = self.types.get(cond_type)

    if not isBool(cond) {
        self.err.errorWithCode(is.span.start, .E300, "condition must be bool")
    }

    try self.checkStmt(is.then_branch)

    if is.else_branch |else_idx| {
        try self.checkStmt(else_idx)
    }
}

// Check while statement.
fn checkWhileStmt(self: *Checker, ws: WhileStmt) !void {
    var cond_type = try self.checkExpr(ws.condition)
    var cond = self.types.get(cond_type)

    if not isBool(cond) {
        self.err.errorWithCode(ws.span.start, .E300, "condition must be bool")
    }

    var old_in_loop = self.in_loop
    self.in_loop = true
    try self.checkStmt(ws.body)
    self.in_loop = old_in_loop
}

// Check for statement.
fn checkForStmt(self: *Checker, fs: ForStmt) !void {
    var iter_type = try self.checkExpr(fs.iterable)
    var iter = self.types.get(iter_type)

    // Determine element type
    var elem_type: TypeIndex = switch iter {
        .array |a| => a.elem,
        .slice |s| => s.elem,
        .basic |k| => if k == .string_type { TypeRegistry.U8 } else { invalid_type },
        else => {
            self.err.errorWithCode(fs.span.start, .E303, "cannot iterate over this type")
            return invalid_type
        },
    }

    // Create scope with loop variable
    var loop_scope = Scope.init(self.scope)

    try loop_scope.define(Symbol.init(fs.binding, .variable, elem_type, null_node, false))

    var old_scope = self.scope
    var old_in_loop = self.in_loop
    self.scope = &loop_scope
    self.in_loop = true

    try self.checkStmt(fs.body)

    self.scope = old_scope
    self.in_loop = old_in_loop
}

// Check block statement.
fn checkBlockStmt(self: *Checker, bs: BlockStmt) !void {
    var block_scope = Scope.init(self.scope)

    var old_scope = self.scope
    self.scope = &block_scope

    for stmt_idx in bs.stmts {
        try self.checkStmt(stmt_idx)
    }

    self.scope = old_scope
}

// ========================================================================
// Type resolution
// ========================================================================

// Resolve a type expression to a TypeIndex.
fn resolveTypeExpr(self: *Checker, idx: NodeIndex) !TypeIndex {
    var node = self.tree.getNode(idx)
    switch node {
        .expr |e| => switch e {
            .type_expr |te| => return self.resolveType(te),
            else => return invalid_type,
        },
        else => return invalid_type,
    }
}

// Resolve a TypeExpr to TypeIndex.
fn resolveType(self: *Checker, te: TypeExpr) !TypeIndex {
    return switch te.kind {
        .named |name| => {
            // Check built-in types first
            if self.types.lookupBasic(name) |idx| {
                return idx
            }
            // Check user-defined types
            if self.scope.lookup(name) |sym| {
                if sym.kind == .type_name {
                    return sym.type_idx
                }
            }
            self.errUndefined(te.span.start, name)
            return invalid_type
        },
        .pointer |elem_idx| => {
            var elem = try self.resolveTypeExpr(elem_idx)
            return self.types.makePointer(elem)
        },
        .optional |elem_idx| => {
            var elem = try self.resolveTypeExpr(elem_idx)
            return self.types.makeOptional(elem)
        },
        .slice |elem_idx| => {
            var elem = try self.resolveTypeExpr(elem_idx)
            return self.types.makeSlice(elem)
        },
        .array |a| => {
            var elem = try self.resolveTypeExpr(a.elem)
            // TODO: evaluate size expression as constant
            return self.types.makeArray(elem, 0)
        },
        .function => {
            // TODO: function types
            return invalid_type
        },
    }
}

// Build a function type from parameters and return type.
fn buildFuncType(self: *Checker, params: []Field, return_type_idx: ?NodeIndex) !TypeIndex {
    var func_params = new List<FuncParam>

    for param in params {
        var param_type = try self.resolveTypeExpr(param.type_expr)
        func_params.push(FuncParam{
            .name = param.name,
            .type_idx = param_type,
        })
    }

    var ret_type: TypeIndex = if return_type_idx |idx| {
        try self.resolveTypeExpr(idx)
    } else {
        TypeRegistry.VOID
    }

    return self.types.add(Type{ .func = FuncType{
        .params = func_params,
        .return_type = ret_type,
    }})
}

// Build a struct type from fields.
fn buildStructType(self: *Checker, name: string, fields: []Field) !TypeIndex {
    var struct_fields = new List<StructField>

    var offset: u32 = 0
    for field in fields {
        var field_type = try self.resolveTypeExpr(field.type_expr)
        var field_size = self.typeSize(field_type)
        struct_fields.push(StructField{
            .name = field.name,
            .type_idx = field_type,
            .offset = offset,
        })
        offset += field_size
    }

    return self.types.add(Type{ .struct_type = StructType{
        .name = name,
        .fields = struct_fields,
        .size = offset,
        .alignment = 8,  // simplified: always 8-byte aligned
    }})
}

// ========================================================================
// Type utilities
// ========================================================================

// Get the size of a type in bytes.
fn typeSize(self: *Checker, idx: TypeIndex) u32 {
    var t = self.types.get(idx)
    return switch t {
        .basic |k| => @intCast(u32, k.size()),
        .pointer, .slice, .func => 8,  // pointer size
        .optional |o| => self.typeSize(o.elem) + 1,  // simplified
        .array |a| => @intCast(u32, a.length) * self.typeSize(a.elem),
        .struct_type |s| => s.size,
        else => 0,
    }
}

// Materialize an untyped type to a concrete type.
fn materializeType(self: *Checker, idx: TypeIndex) TypeIndex {
    var t = self.types.get(idx)
    return switch t {
        .basic |k| => switch k {
            .untyped_int => TypeRegistry.INT,
            .untyped_float => TypeRegistry.FLOAT,
            .untyped_bool => TypeRegistry.BOOL,
            .untyped_string => TypeRegistry.STRING,
            else => idx,
        },
        else => idx,
    }
}

// Check if a value of type `from` can be assigned to a variable of type `to`.
fn isAssignable(self: *Checker, from: TypeIndex, to: TypeIndex) bool {
    if from == invalid_type or to == invalid_type {
        return true  // Skip for error recovery
    }
    return self.types.isAssignable(from, to)
}

// Check if two types are comparable.
fn isComparable(self: *Checker, a: TypeIndex, b: TypeIndex) bool {
    // Same types are comparable
    if self.types.equal(a, b) {
        return true
    }

    // Numeric types are comparable to each other
    var ta = self.types.get(a)
    var tb = self.types.get(b)
    if isNumeric(ta) and isNumeric(tb) {
        return true
    }

    // String types are comparable (for == and !=)
    if isString(ta) and isString(tb) {
        return true
    }

    return false
}

// ========================================================================
// Error helpers
// ========================================================================

fn errUndefined(self: *Checker, pos: Pos, name: string) {
    self.err.errorWithCode(pos, .E301, "undefined variable")
}

fn errRedefined(self: *Checker, pos: Pos, name: string) {
    self.err.errorWithCode(pos, .E302, "redefined identifier")
}

fn errTypeMismatch(self: *Checker, pos: Pos, expected: TypeIndex, got: TypeIndex) {
    self.err.errorWithCode(pos, .E300, "type mismatch")
}

fn errInvalidOp(self: *Checker, pos: Pos, op_kind: string, left: TypeIndex, right: TypeIndex) {
    self.err.errorWithCode(pos, .E303, "invalid operation")
}

// ============================================================================
// Type predicates
// ============================================================================

fn isNumeric(t: Type) bool {
    return switch t {
        .basic |k| => k.isNumeric(),
        else => false,
    }
}

fn isInteger(t: Type) bool {
    return switch t {
        .basic |k| => k.isInteger(),
        else => false,
    }
}

fn isBool(t: Type) bool {
    return switch t {
        .basic |k| => k == .bool_type or k == .untyped_bool,
        else => false,
    }
}

fn isString(t: Type) bool {
    return switch t {
        .basic |k| => k == .string_type or k == .untyped_string,
        else => false,
    }
}
