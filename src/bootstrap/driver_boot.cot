// Compilation driver for cot bootstrap.
// Orchestrates the entire compilation pipeline.
//
// Based on src/driver.zig patterns.
// For stage 1 bootstrap, we only need ARM64 macOS output.
//
// Note: This module depends on types from parser_boot.cot, lower_boot.cot,
// ir_boot.cot, and codegen modules. main_boot.cot imports all of these before
// driver_boot.cot, so those types are available via transitive imports.
// We don't import codegen directly to avoid duplicate definitions.

// =============================================================================
// Target Configuration
// =============================================================================

enum Arch: u8 {
    x86_64,
    aarch64,
}

enum OS: u8 {
    linux,
    macos,
    windows,
}

struct Target {
    arch: Arch,
    os: OS,
}

fn targetNative() Target {
    // For bootstrap, assume ARM64 macOS
    return Target{
        .arch = Arch.aarch64,
        .os = OS.macos,
    }
}

// =============================================================================
// Compile Options
// =============================================================================

struct CompileOptions {
    input_path: string,
    output_path: string,
    target: Target,
    debug_ir: bool,
    debug_ssa: bool,
    debug_codegen: bool,
}

fn compileOptionsNew(input: string, output: string) CompileOptions {
    return CompileOptions{
        .input_path = input,
        .output_path = output,
        .target = targetNative(),
        .debug_ir = false,
        .debug_ssa = false,
        .debug_codegen = false,
    }
}

// =============================================================================
// Compile Result
// =============================================================================

struct CompileResult {
    success: bool,
    error_count: int,
}

fn compileResultSuccess() CompileResult {
    return CompileResult{
        .success = true,
        .error_count = 0,
    }
}

fn compileResultFailure(count: int) CompileResult {
    return CompileResult{
        .success = false,
        .error_count = count,
    }
}

// =============================================================================
// Driver State
// =============================================================================

struct Driver {
    options: CompileOptions,
    source_content: string,
    error_count: int,
}

fn driverNew(opts: CompileOptions) Driver {
    return Driver{
        .options = opts,
        .source_content = "",
        .error_count = 0,
    }
}

// =============================================================================
// Code Generation (IR to Machine Code)
// =============================================================================

// Branch patch record for two-pass codegen
struct BranchPatch {
    offset: int,          // Offset of branch instruction in code buffer
    target_block: int,    // Target block index
    is_conditional: bool, // True for B.EQ (branch if condition false), false for B
    cond: int,            // Condition code (for conditional branches)
}

// Call relocation record for function calls
struct CallRelocation {
    offset: int,          // Offset of BL instruction in code buffer
    func_name: string,    // Target function name (with _ prefix)
}

fn generateCodeFromIR(ir: IRProgram, output_path: string) bool {
    var num_funcs: int = len(ir.funcs)
    if num_funcs == 0 {
        return false
    }

    var obj: ObjectFile = objectFileNew()
    var text_idx: int = objectAddSection(obj, "__text", SectionKind.text)
    var text_sec: Section = objectGetSection(obj, text_idx)

    var n_funcs: int = len(ir.funcs)

    var func_idx: int = 0
    while func_idx < n_funcs {
        var func: IRFunc = ir.funcs.get(func_idx)

        var sym_start: int = sectionSize(text_sec)
        var sym_name: string = "_" + func.name
        objectAddSymbol(obj, symbolNew(sym_name, SymbolKind.func, text_idx, sym_start, 0, true))
        generateFunctionFromIR(&text_sec, func)
        func_idx = func_idx + 1
    }

    // Patch local function calls (BL instructions) before writing
    applyLocalRelocations(&obj)

    var output: OutputBuffer = outputBufferNew()
    writeMachO64(obj, output)
    var result: int = @fileWriteListBytes(output_path, output.bytes)
    return result > 0
}

fn generateFunctionFromIR(text_sec: *Section, func: IRFunc) void {
    var cg: FullCodeGen = fullCodeGenInit(func.frame_size, func.locals)
    cgGenPrologue(&cg, func.frame_size)

    // Spill parameter registers to their stack slots
    // ARM64 ABI: first 8 args in x0-x7, stored to stack for uniform access
    var num_params: int = len(func.params)
    if num_params >= 1 {
        // Param 0: x0 -> stack slot 0 (sp_offset = stack_size + 16 - 8)
        cgSpillParamToStack(&cg, 0, 0)
    }
    if num_params >= 2 {
        // Param 1: x1 -> stack slot 1 (sp_offset = stack_size + 16 - 16)
        cgSpillParamToStack(&cg, 1, 1)
    }
    if num_params >= 3 {
        cgSpillParamToStack(&cg, 2, 2)
    }
    if num_params >= 4 {
        cgSpillParamToStack(&cg, 3, 3)
    }

    // Track block offsets for branch patching
    var block_offsets: List<int> = new List<int>()
    var branch_patches: List<BranchPatch> = new List<BranchPatch>()
    var call_relocs: List<CallRelocation> = new List<CallRelocation>()

    // Pass 1: Generate code for all blocks, emit branch placeholders
    var block_idx: int = 0
    while block_idx < len(func.blocks) {
        // Record block starting offset
        var block_start: int = codeBufferPos(&cg.buf)
        block_offsets.push(block_start)

        var block: IRBlock = func.blocks.get(block_idx)

        var node_idx: int = 0
        var node_count: int = len(block.nodes)
        while node_idx < node_count {
            var ir_node_idx: IRNodeIndex = block.nodes.get(node_idx)
            var ir_node: IRNode = func.nodes.get(ir_node_idx)
            generateNodeFromIREx(&cg, ir_node, ir_node_idx, func, &branch_patches, &call_relocs)
            node_idx = node_idx + 1
        }
        block_idx = block_idx + 1
    }

    // Pass 2: Patch all branch instructions with correct offsets
    var patch_idx: int = 0
    while patch_idx < len(branch_patches) {
        var patch: BranchPatch = branch_patches.get(patch_idx)
        var target_offset: int = block_offsets.get(patch.target_block)
        patchBranchToTarget(&cg, patch.offset, target_offset, patch.is_conditional, patch.cond)
        patch_idx = patch_idx + 1
    }

    // Get section start offset before copying code
    var sec_start: int = sectionSize(text_sec.*)

    // Copy generated code to section
    var byte_count: int = len(cg.buf.bytes)
    var i: int = 0
    while i < byte_count {
        var byte_val: int = cg.buf.bytes.get(i)
        sectionAppendByte(text_sec, byte_val)
        i = i + 1
    }

    // Add call relocations to section (adjusted for section offset)
    var reloc_idx: int = 0
    while reloc_idx < len(call_relocs) {
        var call_rel: CallRelocation = call_relocs.get(reloc_idx)
        var reloc: Relocation = relocationNew(sec_start + call_rel.offset, call_rel.func_name, RelocKind.pc_rel_32, 0)
        sectionAddRelocation(text_sec, reloc)
        reloc_idx = reloc_idx + 1
    }
}

// Patch a branch instruction to jump to a specific target offset
fn patchBranchToTarget(cg: *FullCodeGen, branch_offset: int, target_offset: int, is_conditional: bool, cond: int) void {
    var delta: int = target_offset - branch_offset
    var inst: int = 0

    if is_conditional {
        // B.cond encoding: 01010100 imm19 0 cond
        // Bits: 31-25=0101010, 24=0, 23-5=imm19, 4=0, 3-0=cond
        var imm19: int = delta / 4
        // Handle negative offsets: add 2^19 for negative values
        if imm19 < 0 {
            imm19 = imm19 + 524288
        }
        // 84 * 16777216 = 0x54000000
        inst = (84 * 16777216) + (imm19 * 32) + cond
    } else {
        // B encoding: 000101 imm26
        var imm26: int = delta / 4
        // Handle negative offsets: add 2^26 for negative values
        if imm26 < 0 {
            imm26 = imm26 + 67108864
        }
        // 5 * 67108864 = 0x14000000
        inst = (5 * 67108864) + imm26
    }

    // Write instruction bytes (little-endian)
    var b0: int = inst % 256
    var b1: int = (inst / 256) % 256
    var b2: int = (inst / 65536) % 256
    var b3: int = (inst / 16777216) % 256

    cg.*.buf.bytes[branch_offset] = b0
    cg.*.buf.bytes[branch_offset + 1] = b1
    cg.*.buf.bytes[branch_offset + 2] = b2
    cg.*.buf.bytes[branch_offset + 3] = b3
}

// Extended node generator with branch patch tracking
fn generateNodeFromIREx(cg: *FullCodeGen, node: IRNode, node_idx: IRNodeIndex, func: IRFunc, patches: *List<BranchPatch>, call_relocs: *List<CallRelocation>) void {
    var op: Op = node.op

    if op == Op.const_int {
        cgGenConstInt(cg, node_idx, node.aux)
    } else if op == Op.add {
        cgGenAdd(cg, node_idx, irNodeGetArg(node, 0), irNodeGetArg(node, 1))
    } else if op == Op.sub {
        cgGenSub(cg, node_idx, irNodeGetArg(node, 0), irNodeGetArg(node, 1))
    } else if op == Op.mul {
        cgGenMul(cg, node_idx, irNodeGetArg(node, 0), irNodeGetArg(node, 1))
    } else if op == Op.div {
        cgGenDiv(cg, node_idx, irNodeGetArg(node, 0), irNodeGetArg(node, 1))
    } else if op == Op.eq {
        cgGenCmpEq(cg, node_idx, irNodeGetArg(node, 0), irNodeGetArg(node, 1))
    } else if op == Op.ne {
        cgGenCmpNe(cg, node_idx, irNodeGetArg(node, 0), irNodeGetArg(node, 1))
    } else if op == Op.lt {
        cgGenCmpLt(cg, node_idx, irNodeGetArg(node, 0), irNodeGetArg(node, 1))
    } else if op == Op.le {
        cgGenCmpLe(cg, node_idx, irNodeGetArg(node, 0), irNodeGetArg(node, 1))
    } else if op == Op.gt {
        cgGenCmpGt(cg, node_idx, irNodeGetArg(node, 0), irNodeGetArg(node, 1))
    } else if op == Op.ge {
        cgGenCmpGe(cg, node_idx, irNodeGetArg(node, 0), irNodeGetArg(node, 1))
    } else if op == Op.neg {
        cgGenNeg(cg, node_idx, irNodeGetArg(node, 0))
    } else if op == Op.local {
        cgGenLoadStack(cg, node_idx, 0 - (node.aux + 1) * 8, 8)
    } else if op == Op.store {
        cgGenStoreStack(cg, irNodeGetArg(node, 0), 0 - (node.aux + 1) * 8, 8)
    } else if op == Op.ret {
        cgGenReturn(cg, irNodeGetArg(node, 0))
    } else if op == Op.branch {
        // Conditional branch: args0=condition, args1=true_block, args2=false_block
        generateBranch(cg, node, patches)
    } else if op == Op.jump {
        // Unconditional branch: aux=target_block
        generateJump(cg, node, patches)
    } else if op == Op.call {
        // Function call: aux_str=func_name, args=arguments
        generateCall(cg, node, node_idx, call_relocs)
    } else if op == Op.select {
        // Select: cond ? then_val : else_val
        generateSelect(cg, node, node_idx)
    } else if op == Op.list_set {
        // List index assignment: list_set(handle, index, value)
        generateListSet(cg, node, node_idx)
    } else if op == Op.list_new {
        // Create new list: list_new(elem_size)
        generateListNew(cg, node, node_idx)
    } else if op == Op.list_push {
        // Push to list: list_push(handle, value)
        generateListPush(cg, node, node_idx)
    } else if op == Op.list_get {
        // Get from list: list_get(handle, index)
        generateListGet(cg, node, node_idx)
    } else if op == Op.list_len {
        // Get list length: list_len(handle)
        generateListLen(cg, node, node_idx)
    }
}

// Generate list_set: args[0]=handle, args[1]=index, args[2]=value
fn generateListSet(cg: *FullCodeGen, node: IRNode, node_idx: IRNodeIndex) void {
    // Spill caller-saved registers
    cgSpillCallerSaved(cg)

    // Load arguments: x0=handle, x1=index, x2=value
    cgPrepareArg(cg, 0, irNodeGetArg(node, 0))
    cgPrepareArg(cg, 1, irNodeGetArg(node, 1))
    cgPrepareArg(cg, 2, irNodeGetArg(node, 2))

    // Call _cot_list_set
    emitCallPlaceholder(&cg.*.buf, "_cot_list_set")
}

// Generate list_new: aux=elem_size, returns handle in x0
fn generateListNew(cg: *FullCodeGen, node: IRNode, node_idx: IRNodeIndex) void {
    cgSpillCallerSaved(cg)

    // Load elem_size into x0
    movRegImm64(&cg.*.buf, REG_X0, node.aux)

    // Call _cot_list_new
    emitCallPlaceholder(&cg.*.buf, "_cot_list_new")

    // Result is in x0
    cgMarkReturnValue(cg, node_idx)
}

// Generate list_push: args[0]=handle, args[1]=value
fn generateListPush(cg: *FullCodeGen, node: IRNode, node_idx: IRNodeIndex) void {
    cgSpillCallerSaved(cg)

    cgPrepareArg(cg, 0, irNodeGetArg(node, 0))
    cgPrepareArg(cg, 1, irNodeGetArg(node, 1))

    emitCallPlaceholder(&cg.*.buf, "_cot_list_push")
    cgMarkReturnValue(cg, node_idx)
}

// Generate list_get: args[0]=handle, args[1]=index
fn generateListGet(cg: *FullCodeGen, node: IRNode, node_idx: IRNodeIndex) void {
    cgSpillCallerSaved(cg)

    cgPrepareArg(cg, 0, irNodeGetArg(node, 0))
    cgPrepareArg(cg, 1, irNodeGetArg(node, 1))

    emitCallPlaceholder(&cg.*.buf, "_cot_list_get")
    cgMarkReturnValue(cg, node_idx)
}

// Generate list_len: args[0]=handle
fn generateListLen(cg: *FullCodeGen, node: IRNode, node_idx: IRNodeIndex) void {
    cgSpillCallerSaved(cg)

    cgPrepareArg(cg, 0, irNodeGetArg(node, 0))

    emitCallPlaceholder(&cg.*.buf, "_cot_list_len")
    cgMarkReturnValue(cg, node_idx)
}

// Generate conditional branch
fn generateBranch(cg: *FullCodeGen, node: IRNode, patches: *List<BranchPatch>) void {
    var cond_id: int = irNodeGetArg(node, 0)
    var true_block: int = irNodeGetArg(node, 1)
    var false_block: int = irNodeGetArg(node, 2)

    // Load condition and compare with 0
    var cond_mcv: MCValue = cgGetValue(cg, cond_id)
    cgLoadToReg(cg, SCRATCH0, cond_mcv)
    cmpRegImm(&cg.*.buf, SCRATCH0, 0)

    // B.EQ false_block (branch to false block if condition is zero)
    var beq_offset: int = codeBufferPos(&cg.*.buf)
    emit32(&cg.*.buf, 0)  // Placeholder for B.EQ
    patches.*.push(BranchPatch{
        .offset = beq_offset,
        .target_block = false_block,
        .is_conditional = true,
        .cond = COND_EQ,  // Branch if equal to zero (condition false)
    })

    // B true_block (unconditional branch to true block)
    var b_offset: int = codeBufferPos(&cg.*.buf)
    emit32(&cg.*.buf, 0)  // Placeholder for B
    patches.*.push(BranchPatch{
        .offset = b_offset,
        .target_block = true_block,
        .is_conditional = false,
        .cond = 0,
    })
}

// Generate unconditional jump
fn generateJump(cg: *FullCodeGen, node: IRNode, patches: *List<BranchPatch>) void {
    var target_block: int = node.aux

    // B target_block
    var b_offset: int = codeBufferPos(&cg.*.buf)
    emit32(&cg.*.buf, 0)  // Placeholder for B
    patches.*.push(BranchPatch{
        .offset = b_offset,
        .target_block = target_block,
        .is_conditional = false,
        .cond = 0,
    })
}

// Generate function call
fn generateCall(cg: *FullCodeGen, node: IRNode, node_idx: IRNodeIndex, call_relocs: *List<CallRelocation>) void {
    // Spill caller-saved registers
    cgSpillCallerSaved(cg)

    // Load arguments into registers (x0-x7)
    var num_args: int = node.args_len
    if num_args >= 1 {
        cgPrepareArg(cg, 0, irNodeGetArg(node, 0))
    }
    if num_args >= 2 {
        cgPrepareArg(cg, 1, irNodeGetArg(node, 1))
    }
    if num_args >= 3 {
        cgPrepareArg(cg, 2, irNodeGetArg(node, 2))
    }
    if num_args >= 4 {
        cgPrepareArg(cg, 3, irNodeGetArg(node, 3))
    }

    // Emit BL instruction and record relocation
    var func_name: string = "_" + node.aux_str
    var offset: int = emitCallPlaceholder(&cg.*.buf, func_name)

    // Add call relocation for linker to patch
    var call_rel: CallRelocation = CallRelocation{ .offset = offset, .func_name = func_name }
    call_relocs.*.push(call_rel)

    // Mark return value in x0
    cgMarkReturnValue(cg, node_idx)
}

// Emit BL placeholder for function call
// Returns the offset of the BL instruction so caller can add relocation
fn emitCallPlaceholder(buf: *CodeBuffer, func_name: string) int {
    // Record offset before emitting - caller will add relocation to section
    var offset: int = len(buf.*.bytes)
    // BL with 0 offset - will be patched by applyLocalRelocations
    // BL encoding: 1001 01 [imm26]
    var inst: int = 37 * 67108864  // 0x94000000
    emit32(buf, inst)
    return offset
}

// Generate select: cond ? then_val : else_val
fn generateSelect(cg: *FullCodeGen, node: IRNode, node_idx: IRNodeIndex) void {
    var cond_id: int = irNodeGetArg(node, 0)
    var then_id: int = irNodeGetArg(node, 1)
    var else_id: int = irNodeGetArg(node, 2)

    cgEnsureRegFree(cg, REG_X0)

    // Load condition and compare with 0
    var cond_mcv: MCValue = cgGetValue(cg, cond_id)
    cgLoadToReg(cg, SCRATCH0, cond_mcv)
    cmpRegImm(&cg.*.buf, SCRATCH0, 0)

    // Load then and else values
    var then_mcv: MCValue = cgGetValue(cg, then_id)
    var else_mcv: MCValue = cgGetValue(cg, else_id)
    cgLoadToReg(cg, REG_X0, then_mcv)
    cgLoadToReg(cg, SCRATCH1, else_mcv)

    // CSEL x0, x0, x17, NE (select x0 if cond != 0, else x17)
    var inst: int = encodeCondSelect(1, 0, SCRATCH1, COND_NE, REG_X0, REG_X0)
    emit32(&cg.*.buf, inst)

    regManagerMarkUsed(cg.*.reg_manager, REG_X0, node_idx)
    cgSetResult(cg, node_idx, mcvRegister(REG_X0))
}

fn generateNodeFromIR(cg: *FullCodeGen, node: IRNode, node_idx: IRNodeIndex) void {
    var op: Op = node.op
    if op == Op.const_int {
        cgGenConstInt(cg, node_idx, node.aux)
    } else if op == Op.add {
        cgGenAdd(cg, node_idx, irNodeGetArg(node, 0), irNodeGetArg(node, 1))
    } else if op == Op.sub {
        cgGenSub(cg, node_idx, irNodeGetArg(node, 0), irNodeGetArg(node, 1))
    } else if op == Op.mul {
        cgGenMul(cg, node_idx, irNodeGetArg(node, 0), irNodeGetArg(node, 1))
    } else if op == Op.div {
        cgGenDiv(cg, node_idx, irNodeGetArg(node, 0), irNodeGetArg(node, 1))
    } else if op == Op.eq {
        cgGenCmpEq(cg, node_idx, irNodeGetArg(node, 0), irNodeGetArg(node, 1))
    } else if op == Op.ne {
        cgGenCmpNe(cg, node_idx, irNodeGetArg(node, 0), irNodeGetArg(node, 1))
    } else if op == Op.lt {
        cgGenCmpLt(cg, node_idx, irNodeGetArg(node, 0), irNodeGetArg(node, 1))
    } else if op == Op.le {
        cgGenCmpLe(cg, node_idx, irNodeGetArg(node, 0), irNodeGetArg(node, 1))
    } else if op == Op.gt {
        cgGenCmpGt(cg, node_idx, irNodeGetArg(node, 0), irNodeGetArg(node, 1))
    } else if op == Op.ge {
        cgGenCmpGe(cg, node_idx, irNodeGetArg(node, 0), irNodeGetArg(node, 1))
    } else if op == Op.neg {
        cgGenNeg(cg, node_idx, irNodeGetArg(node, 0))
    } else if op == Op.local {
        cgGenLoadStack(cg, node_idx, 0 - (node.aux + 1) * 8, 8)
    } else if op == Op.store {
        cgGenStoreStack(cg, irNodeGetArg(node, 0), 0 - (node.aux + 1) * 8, 8)
    } else if op == Op.ret {
        cgGenReturn(cg, irNodeGetArg(node, 0))
    } else if op == Op.select {
        generateSelect(cg, node, node_idx)
    }
}

// =============================================================================
// Main Compilation Pipeline
// =============================================================================

fn driverCompile(driver: *Driver) CompileResult {
    // Phase 1: Read source file
    var content: string = @fileRead(driver.*.options.input_path)
    if len(content) == 0 {
        return compileResultFailure(1)
    }
    driver.*.source_content = content

    // Phase 2: Parse
    var parser: ParserState = parserInit(content)
    parser = parseFile(parser)

    if len(parser.nodes) == 0 {
        return compileResultFailure(2)
    }

    // Phase 3: Lower AST to IR
    var lowerer: Lowerer = lowererInit(parser.nodes)
    lowerProgram(&lowerer)

    if lowerer.error_count > 0 {
        return compileResultFailure(lowerer.error_count)
    }

    // Phase 4: Generate code from IR
    var ir: IRProgram = lowerer.ir_builder.ir
    var success: bool = generateCodeFromIR(ir, driver.*.options.output_path)

    if not success {
        return compileResultFailure(1)
    }

    return compileResultSuccess()
}

// =============================================================================
// Public Entry Point
// =============================================================================

fn compileFile(input_path: string, output_path: string) CompileResult {
    var opts: CompileOptions = compileOptionsNew(input_path, output_path)
    var driver: Driver = driverNew(opts)
    return driverCompile(&driver)
}

// =============================================================================
// Test
// =============================================================================

fn test_driver() int {
    // Test driver can read a file
    var opts: CompileOptions = compileOptionsNew("build.zig", "test_out")
    var driver: Driver = driverNew(opts)

    var content: string = @fileRead(driver.options.input_path)
    if len(content) < 100 {
        return 1
    }

    // Test that we read the right file (starts with "const")
    if content[0] != 99 {  // 'c'
        return 2
    }
    if content[1] != 111 { // 'o'
        return 3
    }
    if content[2] != 110 { // 'n'
        return 4
    }
    if content[3] != 115 { // 's'
        return 5
    }
    if content[4] != 116 { // 't'
        return 6
    }

    return 42
}
