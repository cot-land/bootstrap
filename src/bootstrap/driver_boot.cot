// Compilation driver for cot bootstrap.
// Orchestrates the entire compilation pipeline.
//
// Based on src/driver.zig patterns.
// For stage 1 bootstrap, we only need ARM64 macOS output.
//
// Note: This module depends on types from parser_boot.cot, lower_boot.cot,
// ir_boot.cot, and codegen modules. main_boot.cot imports all of these before
// driver_boot.cot, so those types are available via transitive imports.
// We don't import codegen directly to avoid duplicate definitions.

// =============================================================================
// Target Configuration
// =============================================================================

enum Arch: u8 {
    x86_64,
    aarch64,
}

enum OS: u8 {
    linux,
    macos,
    windows,
}

struct Target {
    arch: Arch,
    os: OS,
}

fn targetNative() Target {
    // For bootstrap, assume ARM64 macOS
    return Target{
        .arch = Arch.aarch64,
        .os = OS.macos,
    }
}

// =============================================================================
// Compile Options
// =============================================================================

struct CompileOptions {
    input_path: string,
    output_path: string,
    target: Target,
    debug_ir: bool,
    debug_ssa: bool,
    debug_codegen: bool,
}

fn compileOptionsNew(input: string, output: string) CompileOptions {
    return CompileOptions{
        .input_path = input,
        .output_path = output,
        .target = targetNative(),
        .debug_ir = false,
        .debug_ssa = false,
        .debug_codegen = false,
    }
}

// =============================================================================
// Compile Result
// =============================================================================

struct CompileResult {
    success: bool,
    error_count: int,
}

fn compileResultSuccess() CompileResult {
    return CompileResult{
        .success = true,
        .error_count = 0,
    }
}

fn compileResultFailure(count: int) CompileResult {
    return CompileResult{
        .success = false,
        .error_count = count,
    }
}

// =============================================================================
// Driver State
// =============================================================================

struct Driver {
    options: CompileOptions,
    source_content: string,
    error_count: int,
}

fn driverNew(opts: CompileOptions) Driver {
    return Driver{
        .options = opts,
        .source_content = "",
        .error_count = 0,
    }
}

// =============================================================================
// Code Generation (IR to Machine Code)
// =============================================================================

fn generateCodeFromIR(ir: IRProgram, output_path: string) bool {
    var num_funcs: int = len(ir.funcs)
    if num_funcs == 0 {
        return false
    }

    var obj: ObjectFile = objectFileNew()
    var text_idx: int = objectAddSection(obj, "__text", SectionKind.text)
    var text_sec: Section = objectGetSection(obj, text_idx)

    println("DEBUG: num funcs in IR")
    var n_funcs: int = len(ir.funcs)
    if n_funcs == 0 {
        println("DEBUG: 0 funcs")
    } else if n_funcs == 1 {
        println("DEBUG: 1 func")
    } else {
        println("DEBUG: multiple funcs")
    }

    var func_idx: int = 0
    while func_idx < n_funcs {
        var func: IRFunc = ir.funcs.get(func_idx)
        println("DEBUG: processing func")

        var sym_start: int = sectionSize(text_sec)
        var sym_name: string = "_" + func.name
        objectAddSymbol(obj, symbolNew(sym_name, SymbolKind.func, text_idx, sym_start, 0, true))
        generateFunctionFromIR(&text_sec, func)
        func_idx = func_idx + 1
    }

    var output: OutputBuffer = outputBufferNew()
    writeMachO64(obj, output)
    var result: int = @fileWriteListBytes(output_path, output.bytes)
    return result > 0
}

fn generateFunctionFromIR(text_sec: *Section, func: IRFunc) void {
    var cg: FullCodeGen = fullCodeGenInit(func.frame_size)
    cgGenPrologue(&cg, func.frame_size)

    println("DEBUG: generating blocks")
    var block_idx: int = 0
    while block_idx < len(func.blocks) {
        println("DEBUG: processing block")
        var block: IRBlock = func.blocks.get(block_idx)

        var node_idx: int = 0
        var node_count: int = len(block.nodes)
        while node_idx < node_count {
            var ir_node_idx: IRNodeIndex = block.nodes.get(node_idx)
            var ir_node: IRNode = func.nodes.get(ir_node_idx)
            generateNodeFromIR(&cg, ir_node, ir_node_idx)
            node_idx = node_idx + 1
        }
        block_idx = block_idx + 1
    }

    var byte_count: int = len(cg.buf.bytes)
    println("DEBUG: generateFunction copying bytes")
    var i: int = 0
    while i < byte_count {
        var byte_val: int = cg.buf.bytes.get(i)
        sectionAppendByte(text_sec, byte_val)
        i = i + 1
    }
    println("DEBUG: done copying")
}

fn generateNodeFromIR(cg: *FullCodeGen, node: IRNode, node_idx: IRNodeIndex) void {
    println("DEBUG: generateNode called")
    var op: Op = node.op
    if op == Op.const_int {
        println("DEBUG: generating const_int")
        cgGenConstInt(cg, node_idx, node.aux)
    } else if op == Op.add {
        cgGenAdd(cg, node_idx, irNodeGetArg(node, 0), irNodeGetArg(node, 1))
    } else if op == Op.sub {
        cgGenSub(cg, node_idx, irNodeGetArg(node, 0), irNodeGetArg(node, 1))
    } else if op == Op.mul {
        cgGenMul(cg, node_idx, irNodeGetArg(node, 0), irNodeGetArg(node, 1))
    } else if op == Op.div {
        cgGenDiv(cg, node_idx, irNodeGetArg(node, 0), irNodeGetArg(node, 1))
    } else if op == Op.eq {
        cgGenCmpEq(cg, node_idx, irNodeGetArg(node, 0), irNodeGetArg(node, 1))
    } else if op == Op.ne {
        cgGenCmpNe(cg, node_idx, irNodeGetArg(node, 0), irNodeGetArg(node, 1))
    } else if op == Op.lt {
        cgGenCmpLt(cg, node_idx, irNodeGetArg(node, 0), irNodeGetArg(node, 1))
    } else if op == Op.le {
        cgGenCmpLe(cg, node_idx, irNodeGetArg(node, 0), irNodeGetArg(node, 1))
    } else if op == Op.gt {
        cgGenCmpGt(cg, node_idx, irNodeGetArg(node, 0), irNodeGetArg(node, 1))
    } else if op == Op.ge {
        cgGenCmpGe(cg, node_idx, irNodeGetArg(node, 0), irNodeGetArg(node, 1))
    } else if op == Op.neg {
        cgGenNeg(cg, node_idx, irNodeGetArg(node, 0))
    } else if op == Op.local {
        cgGenLoadStack(cg, node_idx, 0 - (node.aux + 1) * 8, 8)
    } else if op == Op.store {
        cgGenStoreStack(cg, irNodeGetArg(node, 0), 0 - (node.aux + 1) * 8, 8)
    } else if op == Op.ret {
        println("DEBUG: generating ret")
        cgGenReturn(cg, irNodeGetArg(node, 0))
    } else {
        println("DEBUG: unknown op")
    }
}

// =============================================================================
// Main Compilation Pipeline
// =============================================================================

fn driverCompile(driver: *Driver) CompileResult {
    // Phase 1: Read source file
    var content: string = @fileRead(driver.*.options.input_path)
    if len(content) == 0 {
        return compileResultFailure(1)
    }
    driver.*.source_content = content

    // Phase 2: Parse
    var parser: ParserState = parserInit(content)
    parser = parseFile(parser)

    if len(parser.nodes) == 0 {
        return compileResultFailure(2)
    }

    // Phase 3: Lower AST to IR
    var lowerer: Lowerer = lowererInit(parser.nodes)
    lowerProgram(&lowerer)

    if lowerer.error_count > 0 {
        return compileResultFailure(lowerer.error_count)
    }

    // Phase 4: Generate code from IR
    var ir: IRProgram = lowerer.ir_builder.ir
    var success: bool = generateCodeFromIR(ir, driver.*.options.output_path)

    if not success {
        return compileResultFailure(1)
    }

    return compileResultSuccess()
}

// =============================================================================
// Public Entry Point
// =============================================================================

fn compileFile(input_path: string, output_path: string) CompileResult {
    var opts: CompileOptions = compileOptionsNew(input_path, output_path)
    var driver: Driver = driverNew(opts)
    return driverCompile(&driver)
}

// =============================================================================
// Test
// =============================================================================

fn test_driver() int {
    // Test driver can read a file
    var opts: CompileOptions = compileOptionsNew("build.zig", "test_out")
    var driver: Driver = driverNew(opts)

    var content: string = @fileRead(driver.options.input_path)
    if len(content) < 100 {
        return 1
    }

    // Test that we read the right file (starts with "const")
    if content[0] != 99 {  // 'c'
        return 2
    }
    if content[1] != 111 { // 'o'
        return 3
    }
    if content[2] != 110 { // 'n'
        return 4
    }
    if content[3] != 115 { // 's'
        return 5
    }
    if content[4] != 116 { // 't'
        return 6
    }

    return 42
}
