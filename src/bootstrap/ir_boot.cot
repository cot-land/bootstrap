// Typed Intermediate Representation for cot bootstrap.
// Simplified version using only currently-supported features.
//
// Maps to Go's cmd/compile/internal/ir/
// - node.go (Node types)
// - func.go (Function representation)
// - expr.go, stmt.go (lowered operations)
//
// Changes from original ir.zig:
// - Standalone functions instead of methods
// - List<T> for dynamic storage (runtime FFI)
// - No allocator parameters (runtime handles memory)
// - Fixed-size args array in Node instead of slice

// =============================================================================
// Constants
// =============================================================================

const MAX_INLINE_ARGS: int = 8

// =============================================================================
// Index Types
// =============================================================================

type IRNodeIndex = int
type IRBlockIndex = int
type TypeIndex = int

const ir_null_node: IRNodeIndex = @maxInt(i64)
const ir_null_block: IRBlockIndex = @maxInt(i64)

// =============================================================================
// Operations
// =============================================================================

enum Op: u8 {
    // ========== Constants ==========
    const_int,
    const_float,
    const_bool,
    const_null,
    const_slice,

    // ========== Variables ==========
    local,
    global,
    param,

    // ========== Arithmetic ==========
    add,
    sub,
    mul,
    div,
    mod,
    neg,

    // ========== Comparison ==========
    eq,
    ne,
    lt,
    le,
    gt,
    ge,

    // ========== Logical ==========
    op_and,
    op_or,
    op_not,

    // ========== Bitwise ==========
    bit_and,
    bit_or,
    bit_xor,
    bit_not,
    shl,
    shr,

    // ========== Memory ==========
    load,
    store,
    ptr_load,
    ptr_store,
    addr_local,
    addr_field,
    addr_index,
    ptr_field,
    ptr_field_store,

    // ========== Struct/Array/Union ==========
    field_local,
    field_value,
    index_local,
    index_value,
    field,
    index,
    slice_local,
    slice_value,
    slice,
    slice_index,
    union_init,
    union_tag,
    union_payload,

    // ========== Map Operations ==========
    map_new,
    map_set,
    map_get,
    map_has,
    map_size,
    map_free,

    // ========== List Operations ==========
    list_new,
    list_push,
    list_get,
    list_len,
    list_free,

    // ========== String Operations ==========
    str_concat,

    // ========== Control Flow ==========
    call,
    ret,
    jump,
    branch,
    phi,
    select,

    // ========== Conversions ==========
    convert,
    ptr_cast,

    // ========== Misc ==========
    nop,
}

fn opIsTerminator(op: Op) bool {
    return switch op {
        .ret => true,
        .jump => true,
        .branch => true,
        else => false,
    }
}

fn opHasSideEffects(op: Op) bool {
    return switch op {
        .store => true,
        .call => true,
        .ret => true,
        .jump => true,
        .branch => true,
        .ptr_store => true,
        .ptr_field_store => true,
        .map_new => true,
        .map_set => true,
        .map_free => true,
        .list_new => true,
        .list_push => true,
        .list_free => true,
        else => false,
    }
}

// =============================================================================
// IR Node
// =============================================================================

struct IRNode {
    op: Op,
    type_idx: TypeIndex,
    args0: IRNodeIndex,
    args1: IRNodeIndex,
    args2: IRNodeIndex,
    args3: IRNodeIndex,
    args4: IRNodeIndex,
    args5: IRNodeIndex,
    args6: IRNodeIndex,
    args7: IRNodeIndex,
    args_len: int,
    aux: int,
    aux_str: string,
    span_start: int,
    span_end: int,
    block: IRBlockIndex,
}

fn irNodeInit(op: Op, type_idx: TypeIndex, span_start: int, span_end: int) IRNode {
    return IRNode{
        .op = op,
        .type_idx = type_idx,
        .args0 = 0,
        .args1 = 0,
        .args2 = 0,
        .args3 = 0,
        .args4 = 0,
        .args5 = 0,
        .args6 = 0,
        .args7 = 0,
        .args_len = 0,
        .aux = 0,
        .aux_str = "",
        .span_start = span_start,
        .span_end = span_end,
        .block = ir_null_block,
    }
}

fn irNodeGetArg(n: IRNode, idx: int) IRNodeIndex {
    if idx == 0 { return n.args0 }
    if idx == 1 { return n.args1 }
    if idx == 2 { return n.args2 }
    if idx == 3 { return n.args3 }
    if idx == 4 { return n.args4 }
    if idx == 5 { return n.args5 }
    if idx == 6 { return n.args6 }
    if idx == 7 { return n.args7 }
    return ir_null_node
}

fn irNodeSetArg(n: *IRNode, idx: int, val: IRNodeIndex) void {
    if idx == 0 { n.*.args0 = val }
    if idx == 1 { n.*.args1 = val }
    if idx == 2 { n.*.args2 = val }
    if idx == 3 { n.*.args3 = val }
    if idx == 4 { n.*.args4 = val }
    if idx == 5 { n.*.args5 = val }
    if idx == 6 { n.*.args6 = val }
    if idx == 7 { n.*.args7 = val }
}

fn irNodeWithArg0(n: IRNode, arg: IRNodeIndex) IRNode {
    var result: IRNode = n
    result.args0 = arg
    result.args_len = 1
    return result
}

fn irNodeWithArg01(n: IRNode, arg0: IRNodeIndex, arg1: IRNodeIndex) IRNode {
    var result: IRNode = n
    result.args0 = arg0
    result.args1 = arg1
    result.args_len = 2
    return result
}

fn irNodeWithArg012(n: IRNode, arg0: IRNodeIndex, arg1: IRNodeIndex, arg2: IRNodeIndex) IRNode {
    var result: IRNode = n
    result.args0 = arg0
    result.args1 = arg1
    result.args2 = arg2
    result.args_len = 3
    return result
}

fn irNodeWithAux(n: IRNode, aux: int) IRNode {
    var result: IRNode = n
    result.aux = aux
    return result
}

fn irNodeWithAuxStr(n: IRNode, aux_str: string) IRNode {
    var result: IRNode = n
    result.aux_str = aux_str
    return result
}

fn irNodeWithBlock(n: IRNode, block: IRBlockIndex) IRNode {
    var result: IRNode = n
    result.block = block
    return result
}

// Branch accessors - single source of truth for branch format
// Format: args[0]=condition, args[1]=then_block, args[2]=else_block

fn irNodeGetBranchCondition(n: IRNode) IRNodeIndex {
    if n.op != Op.branch or n.args_len < 1 {
        return ir_null_node
    }
    return n.args0
}

fn irNodeGetBranchThenBlock(n: IRNode) IRBlockIndex {
    if n.op != Op.branch or n.args_len < 2 {
        return ir_null_block
    }
    return n.args1
}

fn irNodeGetBranchElseBlock(n: IRNode) IRBlockIndex {
    if n.op != Op.branch or n.args_len < 3 {
        return ir_null_block
    }
    return n.args2
}

// =============================================================================
// Basic Block
// =============================================================================

struct IRBlock {
    index: IRBlockIndex,
    preds: List<IRBlockIndex>,
    succs: List<IRBlockIndex>,
    nodes: List<IRNodeIndex>,
    label: string,
}

fn irBlockInit(index: IRBlockIndex) IRBlock {
    return IRBlock{
        .index = index,
        .preds = new List<IRBlockIndex>(),
        .succs = new List<IRBlockIndex>(),
        .nodes = new List<IRNodeIndex>(),
        .label = "",
    }
}

fn irBlockWithLabel(b: IRBlock, label: string) IRBlock {
    var result: IRBlock = b
    result.label = label
    return result
}

// =============================================================================
// Local Variable
// =============================================================================

struct IRLocal {
    name: string,
    type_idx: TypeIndex,
    slot: int,
    mutable: bool,
    is_param: bool,
    param_idx: int,
    size: int,
    offset: int,
}

fn irLocalInit(name: string, type_idx: TypeIndex, slot: int, mutable: bool) IRLocal {
    return IRLocal{
        .name = name,
        .type_idx = type_idx,
        .slot = slot,
        .mutable = mutable,
        .is_param = false,
        .param_idx = 0,
        .size = 8,
        .offset = 0,
    }
}

fn irLocalInitParam(name: string, type_idx: TypeIndex, param_idx: int, size: int) IRLocal {
    return IRLocal{
        .name = name,
        .type_idx = type_idx,
        .slot = param_idx,
        .mutable = false,
        .is_param = true,
        .param_idx = param_idx,
        .size = size,
        .offset = 0,
    }
}

fn irLocalInitWithSize(name: string, type_idx: TypeIndex, slot: int, mutable: bool, size: int) IRLocal {
    return IRLocal{
        .name = name,
        .type_idx = type_idx,
        .slot = slot,
        .mutable = mutable,
        .is_param = false,
        .param_idx = 0,
        .size = size,
        .offset = 0,
    }
}

// =============================================================================
// Function
// =============================================================================

struct IRFunc {
    name: string,
    type_idx: TypeIndex,
    return_type: TypeIndex,
    params: List<IRLocal>,
    locals: List<IRLocal>,
    blocks: List<IRBlock>,
    entry: IRBlockIndex,
    nodes: List<IRNode>,
    span_start: int,
    span_end: int,
    frame_size: int,
}

fn irFuncInit(name: string, type_idx: TypeIndex, return_type: TypeIndex, span_start: int, span_end: int) IRFunc {
    return IRFunc{
        .name = name,
        .type_idx = type_idx,
        .return_type = return_type,
        .params = new List<IRLocal>(),
        .locals = new List<IRLocal>(),
        .blocks = new List<IRBlock>(),
        .entry = 0,
        .nodes = new List<IRNode>(),
        .span_start = span_start,
        .span_end = span_end,
        .frame_size = 0,
    }
}

// =============================================================================
// Global
// =============================================================================

struct IRGlobal {
    name: string,
    type_idx: TypeIndex,
    init_value: IRNodeIndex,
    is_const: bool,
    span_start: int,
    span_end: int,
}

fn irGlobalInit(name: string, type_idx: TypeIndex, is_const: bool, span_start: int, span_end: int) IRGlobal {
    return IRGlobal{
        .name = name,
        .type_idx = type_idx,
        .init_value = ir_null_node,
        .is_const = is_const,
        .span_start = span_start,
        .span_end = span_end,
    }
}

// =============================================================================
// Struct Definition
// =============================================================================

struct IRStructDef {
    name: string,
    type_idx: TypeIndex,
    span_start: int,
    span_end: int,
}

fn irStructDefInit(name: string, type_idx: TypeIndex, span_start: int, span_end: int) IRStructDef {
    return IRStructDef{
        .name = name,
        .type_idx = type_idx,
        .span_start = span_start,
        .span_end = span_end,
    }
}

// =============================================================================
// IR Program
// =============================================================================

struct IRProgram {
    funcs: List<IRFunc>,
    globals: List<IRGlobal>,
    structs: List<IRStructDef>,
}

fn irProgramInit() IRProgram {
    return IRProgram{
        .funcs = new List<IRFunc>(),
        .globals = new List<IRGlobal>(),
        .structs = new List<IRStructDef>(),
    }
}

fn irProgramGetFunc(ir: IRProgram, name: string) int {
    var i: int = 0
    while i < len(ir.funcs) {
        var f: IRFunc = ir.funcs.get(i)
        if f.name == name {
            return i
        }
        i = i + 1
    }
    return -1
}

fn irProgramGetGlobal(ir: IRProgram, name: string) int {
    var i: int = 0
    while i < len(ir.globals) {
        var g: IRGlobal = ir.globals.get(i)
        if g.name == name {
            return i
        }
        i = i + 1
    }
    return -1
}

// =============================================================================
// Function Builder
// =============================================================================

struct IRFuncBuilder {
    name: string,
    type_idx: TypeIndex,
    return_type: TypeIndex,
    span_start: int,
    span_end: int,
    locals: List<IRLocal>,
    blocks: List<IRBlock>,
    nodes: List<IRNode>,
    current_block: IRBlockIndex,
    local_map: Map<string, int>,
    max_call_ret_size: int,
}

fn irFuncBuilderInit(name: string, type_idx: TypeIndex, return_type: TypeIndex, span_start: int, span_end: int) IRFuncBuilder {
    var fb: IRFuncBuilder = IRFuncBuilder{
        .name = name,
        .type_idx = type_idx,
        .return_type = return_type,
        .span_start = span_start,
        .span_end = span_end,
        .locals = new List<IRLocal>(),
        .blocks = new List<IRBlock>(),
        .nodes = new List<IRNode>(),
        .current_block = 0,
        .local_map = new Map<string, int>(),
        .max_call_ret_size = 0,
    }

    // Create entry block
    fb.blocks.push(irBlockInit(0))

    return fb
}

fn irFuncBuilderAddParam(fb: *IRFuncBuilder, name: string, type_idx: TypeIndex, size: int) int {
    var idx: int = len(fb.*.locals)
    fb.*.locals.push(irLocalInitParam(name, type_idx, idx, size))
    fb.*.local_map.set(name, idx)
    return idx
}

fn irFuncBuilderAddLocal(fb: *IRFuncBuilder, name: string, type_idx: TypeIndex, mutable: bool) int {
    var idx: int = len(fb.*.locals)
    fb.*.locals.push(irLocalInit(name, type_idx, idx, mutable))
    fb.*.local_map.set(name, idx)
    return idx
}

fn irFuncBuilderAddLocalWithSize(fb: *IRFuncBuilder, name: string, type_idx: TypeIndex, mutable: bool, size: int) int {
    var idx: int = len(fb.*.locals)
    fb.*.locals.push(irLocalInitWithSize(name, type_idx, idx, mutable, size))
    fb.*.local_map.set(name, idx)
    return idx
}

fn irFuncBuilderLookupLocal(fb: IRFuncBuilder, name: string) int {
    if fb.local_map.has(name) {
        return fb.local_map.get(name)
    }
    return -1
}

fn irFuncBuilderNewBlock(fb: *IRFuncBuilder, label: string) IRBlockIndex {
    var idx: IRBlockIndex = len(fb.*.blocks)
    var block: IRBlock = irBlockInit(idx)
    block.label = label
    fb.*.blocks.push(block)
    return idx
}

fn irFuncBuilderSetBlock(fb: *IRFuncBuilder, block: IRBlockIndex) void {
    fb.*.current_block = block
}

fn irFuncBuilderEmit(fb: *IRFuncBuilder, node: IRNode) IRNodeIndex {
    println("DEBUG: irFuncBuilderEmit enter")
    var idx: IRNodeIndex = len(fb.*.nodes)
    println("DEBUG: got idx")
    var n: IRNode = node
    n.block = fb.*.current_block
    println("DEBUG: about to push to fb.*.nodes")
    fb.*.nodes.push(n)
    println("DEBUG: pushed node")

    // Add to current block's node list
    var block: IRBlock = fb.*.blocks.get(fb.*.current_block)
    println("DEBUG: got block")
    block.nodes.push(idx)
    println("DEBUG: pushed to block.nodes")

    return idx
}

fn irFuncBuilderEmitConstInt(fb: *IRFuncBuilder, value: int, type_idx: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.const_int, type_idx, span_start, span_end)
    n.aux = value
    return irFuncBuilderEmit(fb, n)
}

fn irFuncBuilderEmitConstBool(fb: *IRFuncBuilder, value: bool, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.const_bool, 1, span_start, span_end)
    if value {
        n.aux = 1
    } else {
        n.aux = 0
    }
    return irFuncBuilderEmit(fb, n)
}

fn irFuncBuilderEmitConstSlice(fb: *IRFuncBuilder, string_idx: int, type_idx: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.const_slice, type_idx, span_start, span_end)
    n.aux = string_idx
    return irFuncBuilderEmit(fb, n)
}

fn irFuncBuilderEmitLocalLoad(fb: *IRFuncBuilder, local_idx: int, type_idx: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.local, type_idx, span_start, span_end)
    n.aux = local_idx
    return irFuncBuilderEmit(fb, n)
}

fn irFuncBuilderEmitLocalStore(fb: *IRFuncBuilder, local_idx: int, value: IRNodeIndex, type_idx: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.store, type_idx, span_start, span_end)
    n = irNodeWithArg0(n, value)
    n.aux = local_idx
    return irFuncBuilderEmit(fb, n)
}

fn irFuncBuilderEmitBinary(fb: *IRFuncBuilder, op: Op, left: IRNodeIndex, right: IRNodeIndex, type_idx: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(op, type_idx, span_start, span_end)
    n = irNodeWithArg01(n, left, right)
    return irFuncBuilderEmit(fb, n)
}

fn irFuncBuilderEmitUnary(fb: *IRFuncBuilder, op: Op, operand: IRNodeIndex, type_idx: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(op, type_idx, span_start, span_end)
    n = irNodeWithArg0(n, operand)
    return irFuncBuilderEmit(fb, n)
}

fn irFuncBuilderEmitReturn(fb: *IRFuncBuilder, value: IRNodeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.ret, 12, span_start, span_end)
    if value != ir_null_node {
        n = irNodeWithArg0(n, value)
    }
    return irFuncBuilderEmit(fb, n)
}

fn irFuncBuilderEmitJump(fb: *IRFuncBuilder, target: IRBlockIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.jump, 12, span_start, span_end)
    n.aux = target
    return irFuncBuilderEmit(fb, n)
}

fn irFuncBuilderEmitBranch(fb: *IRFuncBuilder, cond: IRNodeIndex, true_block: IRBlockIndex, false_block: IRBlockIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.branch, 12, span_start, span_end)
    n = irNodeWithArg012(n, cond, true_block, false_block)
    return irFuncBuilderEmit(fb, n)
}

fn irFuncBuilderEmitField(fb: *IRFuncBuilder, base: IRNodeIndex, field_offset: int, type_idx: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.field, type_idx, span_start, span_end)
    n = irNodeWithArg0(n, base)
    n.aux = field_offset
    return irFuncBuilderEmit(fb, n)
}

fn irFuncBuilderEmitIndex(fb: *IRFuncBuilder, base: IRNodeIndex, index: IRNodeIndex, type_idx: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.index, type_idx, span_start, span_end)
    n = irNodeWithArg01(n, base, index)
    return irFuncBuilderEmit(fb, n)
}

// Round up to alignment (must be power of 2)
fn roundUp(offset: int, alignment: int) int {
    return ((offset + alignment - 1) / alignment) * alignment
}

fn irFuncBuilderBuild(fb: IRFuncBuilder) IRFunc {
    // Collect params from locals
    var params: List<IRLocal> = new List<IRLocal>()
    var i: int = 0
    while i < len(fb.locals) {
        var local: IRLocal = fb.locals.get(i)
        if local.is_param {
            params.push(local)
        }
        i = i + 1
    }

    // Compute stack frame layout
    var frame_offset: int = 0
    i = 0
    while i < len(fb.locals) {
        var local: IRLocal = fb.locals.get(i)
        // Round up to 8-byte alignment
        frame_offset = roundUp(frame_offset, 8)
        // Assign offset (negative for rbp-relative)
        local.offset = 0 - frame_offset - local.size
        // Advance by variable size
        frame_offset = frame_offset + local.size
        i = i + 1
    }

    // Add space for struct return temps
    frame_offset = frame_offset + fb.max_call_ret_size

    // Round total frame size to 16-byte alignment
    var frame_size: int = roundUp(frame_offset, 16)

    return IRFunc{
        .name = fb.name,
        .type_idx = fb.type_idx,
        .return_type = fb.return_type,
        .params = params,
        .locals = fb.locals,
        .blocks = fb.blocks,
        .entry = 0,
        .nodes = fb.nodes,
        .span_start = fb.span_start,
        .span_end = fb.span_end,
        .frame_size = frame_size,
    }
}

// =============================================================================
// IR Program Builder
// =============================================================================

struct IRProgramBuilder {
    ir: IRProgram,
    current_func: IRFuncBuilder,
    has_func: bool,
}

fn irProgramBuilderInit() IRProgramBuilder {
    return IRProgramBuilder{
        .ir = irProgramInit(),
        .current_func = irFuncBuilderInit("", 0, 0, 0, 0),
        .has_func = false,
    }
}

fn irProgramBuilderStartFunc(b: *IRProgramBuilder, name: string, type_idx: TypeIndex, return_type: TypeIndex, span_start: int, span_end: int) void {
    b.*.current_func = irFuncBuilderInit(name, type_idx, return_type, span_start, span_end)
    b.*.has_func = true
}

fn irProgramBuilderEndFunc(b: *IRProgramBuilder) void {
    if b.*.has_func {
        var func: IRFunc = irFuncBuilderBuild(b.*.current_func)
        b.*.ir.funcs.push(func)
        b.*.has_func = false
    }
}

fn irProgramBuilderAddFunc(b: *IRProgramBuilder, f: IRFunc) void {
    print("AF1")
    var builder: IRProgramBuilder = b.*
    print("AF2")
    var ir_prog: IRProgram = builder.ir
    print("AF3")
    var funcs: List<IRFunc> = ir_prog.funcs
    print("AF4")
    funcs.push(f)
    print("AF5")
}

fn irProgramBuilderAddGlobal(b: *IRProgramBuilder, g: IRGlobal) void {
    b.*.ir.globals.push(g)
}

fn irProgramBuilderAddStruct(b: *IRProgramBuilder, s: IRStructDef) void {
    b.*.ir.structs.push(s)
}

fn irProgramBuilderGetIR(b: IRProgramBuilder) IRProgram {
    return b.ir
}

// =============================================================================
// Simple test
// =============================================================================

fn test_ir() int {
    // Test node creation
    var n: IRNode = irNodeInit(Op.const_int, 5, 0, 10)
    n = irNodeWithAux(n, 42)
    if n.op != Op.const_int {
        return 1
    }
    if n.aux != 42 {
        return 2
    }

    // Test op properties
    if not opIsTerminator(Op.ret) {
        return 3
    }
    if not opIsTerminator(Op.jump) {
        return 4
    }
    if opIsTerminator(Op.add) {
        return 5
    }
    if not opHasSideEffects(Op.call) {
        return 6
    }
    if opHasSideEffects(Op.add) {
        return 7
    }

    // Test block creation
    var block: IRBlock = irBlockInit(0)
    if block.index != 0 {
        return 8
    }

    // Test local creation
    var local: IRLocal = irLocalInit("x", 5, 0, true)
    if local.name != "x" {
        return 9
    }
    if not local.mutable {
        return 10
    }

    // Test local with param
    var param: IRLocal = irLocalInitParam("a", 5, 0, 8)
    if not param.is_param {
        return 11
    }
    if param.size != 8 {
        return 12
    }

    // Test func builder
    var fb: IRFuncBuilder = irFuncBuilderInit("test_fn", 0, 5, 0, 100)
    var param_idx: int = irFuncBuilderAddParam(&fb, "x", 5, 8)
    if param_idx != 0 {
        return 13
    }

    var local_idx: int = irFuncBuilderAddLocal(&fb, "y", 5, true)
    if local_idx != 1 {
        return 14
    }

    // Test lookup
    var found_idx: int = irFuncBuilderLookupLocal(fb, "x")
    if found_idx != 0 {
        return 15
    }

    var not_found: int = irFuncBuilderLookupLocal(fb, "z")
    if not_found != -1 {
        return 16
    }

    // Test emitting nodes
    var load_x: IRNodeIndex = irFuncBuilderEmitLocalLoad(&fb, 0, 5, 0, 10)
    if load_x != 0 {
        return 17
    }

    var const_1: IRNodeIndex = irFuncBuilderEmitConstInt(&fb, 1, 5, 0, 10)
    var add_node: IRNodeIndex = irFuncBuilderEmitBinary(&fb, Op.add, load_x, const_1, 5, 0, 10)
    var ret_node: IRNodeIndex = irFuncBuilderEmitReturn(&fb, add_node, 0, 10)

    if ret_node != 3 {
        return 18
    }

    // Test building func - skip for now due to large struct return issues
    // var func: IRFunc = irFuncBuilderBuild(fb)
    // if func.name != "test_fn" {
    //     return 19
    // }
    // if len(func.params) != 1 {
    //     return 20
    // }
    // if len(func.locals) != 2 {
    //     return 21
    // }
    // if len(func.nodes) != 4 {
    //     return 22
    // }

    // Test roundUp function
    if roundUp(0, 8) != 0 {
        return 23
    }
    if roundUp(1, 8) != 8 {
        return 24
    }
    if roundUp(8, 8) != 8 {
        return 25
    }
    if roundUp(9, 16) != 16 {
        return 26
    }

    // Skip IRProgramBuilder tests that use irFuncBuilderBuild (large struct return issue)
    // TODO: Fix large struct returns in codegen

    // Test global
    var g: IRGlobal = irGlobalInit("MAX_SIZE", 5, true, 0, 20)
    if g.name != "MAX_SIZE" {
        return 30
    }
    if not g.is_const {
        return 31
    }

    // Test struct def
    var sd: IRStructDef = irStructDefInit("Point", 100, 0, 30)
    if sd.name != "Point" {
        return 32
    }

    // Test branch accessors
    var branch_node: IRNode = irNodeInit(Op.branch, 12, 0, 10)
    branch_node = irNodeWithArg012(branch_node, 99, 1, 2)
    if irNodeGetBranchCondition(branch_node) != 99 {
        return 33
    }
    if irNodeGetBranchThenBlock(branch_node) != 1 {
        return 34
    }
    if irNodeGetBranchElseBlock(branch_node) != 2 {
        return 35
    }

    // Test node arg getters
    var test_node: IRNode = irNodeInit(Op.add, 5, 0, 10)
    test_node = irNodeWithArg01(test_node, 10, 20)
    if irNodeGetArg(test_node, 0) != 10 {
        return 36
    }
    if irNodeGetArg(test_node, 1) != 20 {
        return 37
    }

    // Test irNodeSetArg
    var mut_node: IRNode = irNodeInit(Op.call, 5, 0, 10)
    irNodeSetArg(&mut_node, 0, 100)
    irNodeSetArg(&mut_node, 1, 200)
    if irNodeGetArg(mut_node, 0) != 100 {
        return 38
    }
    if irNodeGetArg(mut_node, 1) != 200 {
        return 39
    }

    return 42
}
