// Typed Intermediate Representation for cot bootstrap.
// Simplified version using only currently-supported features.
//
// Maps to Go's cmd/compile/internal/ir/
// - node.go (Node types)
// - func.go (Function representation)
// - expr.go, stmt.go (lowered operations)
//
// Changes from original ir.zig:
// - Standalone functions instead of methods
// - List<T> for dynamic storage (runtime FFI)
// - No allocator parameters (runtime handles memory)
// - Fixed-size args array in Node instead of slice

// =============================================================================
// Constants
// =============================================================================

const MAX_INLINE_ARGS: int = 8

// =============================================================================
// Index Types
// =============================================================================

type NodeIndex = int
type BlockIndex = int
type TypeIndex = int

const null_node: NodeIndex = @maxInt(i64)
const null_block: BlockIndex = @maxInt(i64)

// =============================================================================
// Operations
// =============================================================================

enum Op: u8 {
    // ========== Constants ==========
    const_int,
    const_float,
    const_bool,
    const_null,
    const_slice,

    // ========== Variables ==========
    local,
    global,
    param,

    // ========== Arithmetic ==========
    add,
    sub,
    mul,
    div,
    mod,
    neg,

    // ========== Comparison ==========
    eq,
    ne,
    lt,
    le,
    gt,
    ge,

    // ========== Logical ==========
    op_and,
    op_or,
    op_not,

    // ========== Bitwise ==========
    bit_and,
    bit_or,
    bit_xor,
    bit_not,
    shl,
    shr,

    // ========== Memory ==========
    load,
    store,
    ptr_load,
    ptr_store,
    addr_local,
    addr_field,
    addr_index,
    ptr_field,
    ptr_field_store,

    // ========== Struct/Array/Union ==========
    field_local,
    field_value,
    index_local,
    index_value,
    field,
    index,
    slice_local,
    slice_value,
    slice,
    slice_index,
    union_init,
    union_tag,
    union_payload,

    // ========== Map Operations ==========
    map_new,
    map_set,
    map_get,
    map_has,
    map_size,
    map_free,

    // ========== List Operations ==========
    list_new,
    list_push,
    list_get,
    list_len,
    list_free,

    // ========== String Operations ==========
    str_concat,

    // ========== Control Flow ==========
    call,
    ret,
    jump,
    branch,
    phi,
    select,

    // ========== Conversions ==========
    convert,
    ptr_cast,

    // ========== Misc ==========
    nop,
}

fn opIsTerminator(op: Op) bool {
    return switch op {
        .ret => true,
        .jump => true,
        .branch => true,
        else => false,
    }
}

fn opHasSideEffects(op: Op) bool {
    return switch op {
        .store => true,
        .call => true,
        .ret => true,
        .jump => true,
        .branch => true,
        .ptr_store => true,
        .ptr_field_store => true,
        .map_new => true,
        .map_set => true,
        .map_free => true,
        .list_new => true,
        .list_push => true,
        .list_free => true,
        else => false,
    }
}

// =============================================================================
// IR Node
// =============================================================================

struct Node {
    op: Op,
    type_idx: TypeIndex,
    args0: NodeIndex,
    args1: NodeIndex,
    args2: NodeIndex,
    args3: NodeIndex,
    args4: NodeIndex,
    args5: NodeIndex,
    args6: NodeIndex,
    args7: NodeIndex,
    args_len: int,
    aux: int,
    aux_str: string,
    span_start: int,
    span_end: int,
    block: BlockIndex,
}

fn nodeInit(op: Op, type_idx: TypeIndex, span_start: int, span_end: int) Node {
    return Node{
        .op = op,
        .type_idx = type_idx,
        .args0 = 0,
        .args1 = 0,
        .args2 = 0,
        .args3 = 0,
        .args4 = 0,
        .args5 = 0,
        .args6 = 0,
        .args7 = 0,
        .args_len = 0,
        .aux = 0,
        .aux_str = "",
        .span_start = span_start,
        .span_end = span_end,
        .block = null_block,
    }
}

fn nodeGetArg(n: Node, idx: int) NodeIndex {
    if idx == 0 { return n.args0 }
    if idx == 1 { return n.args1 }
    if idx == 2 { return n.args2 }
    if idx == 3 { return n.args3 }
    if idx == 4 { return n.args4 }
    if idx == 5 { return n.args5 }
    if idx == 6 { return n.args6 }
    if idx == 7 { return n.args7 }
    return null_node
}

fn nodeSetArg(n: *Node, idx: int, val: NodeIndex) void {
    if idx == 0 { n.*.args0 = val }
    if idx == 1 { n.*.args1 = val }
    if idx == 2 { n.*.args2 = val }
    if idx == 3 { n.*.args3 = val }
    if idx == 4 { n.*.args4 = val }
    if idx == 5 { n.*.args5 = val }
    if idx == 6 { n.*.args6 = val }
    if idx == 7 { n.*.args7 = val }
}

fn nodeWithArg0(n: Node, arg: NodeIndex) Node {
    var result: Node = n
    result.args0 = arg
    result.args_len = 1
    return result
}

fn nodeWithArg01(n: Node, arg0: NodeIndex, arg1: NodeIndex) Node {
    var result: Node = n
    result.args0 = arg0
    result.args1 = arg1
    result.args_len = 2
    return result
}

fn nodeWithArg012(n: Node, arg0: NodeIndex, arg1: NodeIndex, arg2: NodeIndex) Node {
    var result: Node = n
    result.args0 = arg0
    result.args1 = arg1
    result.args2 = arg2
    result.args_len = 3
    return result
}

fn nodeWithAux(n: Node, aux: int) Node {
    var result: Node = n
    result.aux = aux
    return result
}

fn nodeWithAuxStr(n: Node, aux_str: string) Node {
    var result: Node = n
    result.aux_str = aux_str
    return result
}

fn nodeWithBlock(n: Node, block: BlockIndex) Node {
    var result: Node = n
    result.block = block
    return result
}

// Branch accessors - single source of truth for branch format
// Format: args[0]=condition, args[1]=then_block, args[2]=else_block

fn nodeGetBranchCondition(n: Node) NodeIndex {
    if n.op != Op.branch or n.args_len < 1 {
        return null_node
    }
    return n.args0
}

fn nodeGetBranchThenBlock(n: Node) BlockIndex {
    if n.op != Op.branch or n.args_len < 2 {
        return null_block
    }
    return n.args1
}

fn nodeGetBranchElseBlock(n: Node) BlockIndex {
    if n.op != Op.branch or n.args_len < 3 {
        return null_block
    }
    return n.args2
}

// =============================================================================
// Basic Block
// =============================================================================

struct Block {
    index: BlockIndex,
    preds: List<BlockIndex>,
    succs: List<BlockIndex>,
    nodes: List<NodeIndex>,
    label: string,
}

fn blockInit(index: BlockIndex) Block {
    return Block{
        .index = index,
        .preds = new List<BlockIndex>(),
        .succs = new List<BlockIndex>(),
        .nodes = new List<NodeIndex>(),
        .label = "",
    }
}

fn blockWithLabel(b: Block, label: string) Block {
    var result: Block = b
    result.label = label
    return result
}

// =============================================================================
// Local Variable
// =============================================================================

struct Local {
    name: string,
    type_idx: TypeIndex,
    slot: int,
    mutable: bool,
    is_param: bool,
    param_idx: int,
    size: int,
    offset: int,
}

fn localInit(name: string, type_idx: TypeIndex, slot: int, mutable: bool) Local {
    return Local{
        .name = name,
        .type_idx = type_idx,
        .slot = slot,
        .mutable = mutable,
        .is_param = false,
        .param_idx = 0,
        .size = 8,
        .offset = 0,
    }
}

fn localInitParam(name: string, type_idx: TypeIndex, param_idx: int, size: int) Local {
    return Local{
        .name = name,
        .type_idx = type_idx,
        .slot = param_idx,
        .mutable = false,
        .is_param = true,
        .param_idx = param_idx,
        .size = size,
        .offset = 0,
    }
}

fn localInitWithSize(name: string, type_idx: TypeIndex, slot: int, mutable: bool, size: int) Local {
    return Local{
        .name = name,
        .type_idx = type_idx,
        .slot = slot,
        .mutable = mutable,
        .is_param = false,
        .param_idx = 0,
        .size = size,
        .offset = 0,
    }
}

// =============================================================================
// Function
// =============================================================================

struct Func {
    name: string,
    type_idx: TypeIndex,
    return_type: TypeIndex,
    params: List<Local>,
    locals: List<Local>,
    blocks: List<Block>,
    entry: BlockIndex,
    nodes: List<Node>,
    span_start: int,
    span_end: int,
    frame_size: int,
}

fn funcInit(name: string, type_idx: TypeIndex, return_type: TypeIndex, span_start: int, span_end: int) Func {
    return Func{
        .name = name,
        .type_idx = type_idx,
        .return_type = return_type,
        .params = new List<Local>(),
        .locals = new List<Local>(),
        .blocks = new List<Block>(),
        .entry = 0,
        .nodes = new List<Node>(),
        .span_start = span_start,
        .span_end = span_end,
        .frame_size = 0,
    }
}

// =============================================================================
// Global
// =============================================================================

struct Global {
    name: string,
    type_idx: TypeIndex,
    init_value: NodeIndex,
    is_const: bool,
    span_start: int,
    span_end: int,
}

fn globalInit(name: string, type_idx: TypeIndex, is_const: bool, span_start: int, span_end: int) Global {
    return Global{
        .name = name,
        .type_idx = type_idx,
        .init_value = null_node,
        .is_const = is_const,
        .span_start = span_start,
        .span_end = span_end,
    }
}

// =============================================================================
// Struct Definition
// =============================================================================

struct StructDef {
    name: string,
    type_idx: TypeIndex,
    span_start: int,
    span_end: int,
}

fn structDefInit(name: string, type_idx: TypeIndex, span_start: int, span_end: int) StructDef {
    return StructDef{
        .name = name,
        .type_idx = type_idx,
        .span_start = span_start,
        .span_end = span_end,
    }
}

// =============================================================================
// IR Program
// =============================================================================

struct IR {
    funcs: List<Func>,
    globals: List<Global>,
    structs: List<StructDef>,
}

fn irInit() IR {
    return IR{
        .funcs = new List<Func>(),
        .globals = new List<Global>(),
        .structs = new List<StructDef>(),
    }
}

fn irGetFunc(ir: IR, name: string) int {
    var i: int = 0
    while i < len(ir.funcs) {
        var f: Func = ir.funcs.get(i)
        if f.name == name {
            return i
        }
        i = i + 1
    }
    return -1
}

fn irGetGlobal(ir: IR, name: string) int {
    var i: int = 0
    while i < len(ir.globals) {
        var g: Global = ir.globals.get(i)
        if g.name == name {
            return i
        }
        i = i + 1
    }
    return -1
}

// =============================================================================
// Function Builder
// =============================================================================

struct FuncBuilder {
    name: string,
    type_idx: TypeIndex,
    return_type: TypeIndex,
    span_start: int,
    span_end: int,
    locals: List<Local>,
    blocks: List<Block>,
    nodes: List<Node>,
    current_block: BlockIndex,
    local_map: Map<string, int>,
    max_call_ret_size: int,
}

fn funcBuilderInit(name: string, type_idx: TypeIndex, return_type: TypeIndex, span_start: int, span_end: int) FuncBuilder {
    var fb: FuncBuilder = FuncBuilder{
        .name = name,
        .type_idx = type_idx,
        .return_type = return_type,
        .span_start = span_start,
        .span_end = span_end,
        .locals = new List<Local>(),
        .blocks = new List<Block>(),
        .nodes = new List<Node>(),
        .current_block = 0,
        .local_map = new Map<string, int>(),
        .max_call_ret_size = 0,
    }

    // Create entry block
    fb.blocks.push(blockInit(0))

    return fb
}

fn funcBuilderAddParam(fb: *FuncBuilder, name: string, type_idx: TypeIndex, size: int) int {
    var idx: int = len(fb.*.locals)
    fb.*.locals.push(localInitParam(name, type_idx, idx, size))
    fb.*.local_map.set(name, idx)
    return idx
}

fn funcBuilderAddLocal(fb: *FuncBuilder, name: string, type_idx: TypeIndex, mutable: bool) int {
    var idx: int = len(fb.*.locals)
    fb.*.locals.push(localInit(name, type_idx, idx, mutable))
    fb.*.local_map.set(name, idx)
    return idx
}

fn funcBuilderAddLocalWithSize(fb: *FuncBuilder, name: string, type_idx: TypeIndex, mutable: bool, size: int) int {
    var idx: int = len(fb.*.locals)
    fb.*.locals.push(localInitWithSize(name, type_idx, idx, mutable, size))
    fb.*.local_map.set(name, idx)
    return idx
}

fn funcBuilderLookupLocal(fb: FuncBuilder, name: string) int {
    if fb.local_map.has(name) {
        return fb.local_map.get(name)
    }
    return -1
}

fn funcBuilderNewBlock(fb: *FuncBuilder, label: string) BlockIndex {
    var idx: BlockIndex = len(fb.*.blocks)
    var block: Block = blockInit(idx)
    block.label = label
    fb.*.blocks.push(block)
    return idx
}

fn funcBuilderSetBlock(fb: *FuncBuilder, block: BlockIndex) void {
    fb.*.current_block = block
}

fn funcBuilderEmit(fb: *FuncBuilder, node: Node) NodeIndex {
    var idx: NodeIndex = len(fb.*.nodes)
    var n: Node = node
    n.block = fb.*.current_block
    fb.*.nodes.push(n)

    // Add to current block's node list
    var block: Block = fb.*.blocks.get(fb.*.current_block)
    block.nodes.push(idx)

    return idx
}

fn funcBuilderEmitConstInt(fb: *FuncBuilder, value: int, type_idx: TypeIndex, span_start: int, span_end: int) NodeIndex {
    var n: Node = nodeInit(Op.const_int, type_idx, span_start, span_end)
    n.aux = value
    return funcBuilderEmit(fb, n)
}

fn funcBuilderEmitConstBool(fb: *FuncBuilder, value: bool, span_start: int, span_end: int) NodeIndex {
    var n: Node = nodeInit(Op.const_bool, 1, span_start, span_end)
    if value {
        n.aux = 1
    } else {
        n.aux = 0
    }
    return funcBuilderEmit(fb, n)
}

fn funcBuilderEmitConstSlice(fb: *FuncBuilder, string_idx: int, type_idx: TypeIndex, span_start: int, span_end: int) NodeIndex {
    var n: Node = nodeInit(Op.const_slice, type_idx, span_start, span_end)
    n.aux = string_idx
    return funcBuilderEmit(fb, n)
}

fn funcBuilderEmitLocalLoad(fb: *FuncBuilder, local_idx: int, type_idx: TypeIndex, span_start: int, span_end: int) NodeIndex {
    var n: Node = nodeInit(Op.local, type_idx, span_start, span_end)
    n.aux = local_idx
    return funcBuilderEmit(fb, n)
}

fn funcBuilderEmitLocalStore(fb: *FuncBuilder, local_idx: int, value: NodeIndex, type_idx: TypeIndex, span_start: int, span_end: int) NodeIndex {
    var n: Node = nodeInit(Op.store, type_idx, span_start, span_end)
    n = nodeWithArg0(n, value)
    n.aux = local_idx
    return funcBuilderEmit(fb, n)
}

fn funcBuilderEmitBinary(fb: *FuncBuilder, op: Op, left: NodeIndex, right: NodeIndex, type_idx: TypeIndex, span_start: int, span_end: int) NodeIndex {
    var n: Node = nodeInit(op, type_idx, span_start, span_end)
    n = nodeWithArg01(n, left, right)
    return funcBuilderEmit(fb, n)
}

fn funcBuilderEmitUnary(fb: *FuncBuilder, op: Op, operand: NodeIndex, type_idx: TypeIndex, span_start: int, span_end: int) NodeIndex {
    var n: Node = nodeInit(op, type_idx, span_start, span_end)
    n = nodeWithArg0(n, operand)
    return funcBuilderEmit(fb, n)
}

fn funcBuilderEmitReturn(fb: *FuncBuilder, value: NodeIndex, span_start: int, span_end: int) NodeIndex {
    var n: Node = nodeInit(Op.ret, 12, span_start, span_end)
    if value != null_node {
        n = nodeWithArg0(n, value)
    }
    return funcBuilderEmit(fb, n)
}

fn funcBuilderEmitJump(fb: *FuncBuilder, target: BlockIndex, span_start: int, span_end: int) NodeIndex {
    var n: Node = nodeInit(Op.jump, 12, span_start, span_end)
    n.aux = target
    return funcBuilderEmit(fb, n)
}

fn funcBuilderEmitBranch(fb: *FuncBuilder, cond: NodeIndex, true_block: BlockIndex, false_block: BlockIndex, span_start: int, span_end: int) NodeIndex {
    var n: Node = nodeInit(Op.branch, 12, span_start, span_end)
    n = nodeWithArg012(n, cond, true_block, false_block)
    return funcBuilderEmit(fb, n)
}

fn funcBuilderEmitField(fb: *FuncBuilder, base: NodeIndex, field_offset: int, type_idx: TypeIndex, span_start: int, span_end: int) NodeIndex {
    var n: Node = nodeInit(Op.field, type_idx, span_start, span_end)
    n = nodeWithArg0(n, base)
    n.aux = field_offset
    return funcBuilderEmit(fb, n)
}

fn funcBuilderEmitIndex(fb: *FuncBuilder, base: NodeIndex, index: NodeIndex, type_idx: TypeIndex, span_start: int, span_end: int) NodeIndex {
    var n: Node = nodeInit(Op.index, type_idx, span_start, span_end)
    n = nodeWithArg01(n, base, index)
    return funcBuilderEmit(fb, n)
}

// Round up to alignment (must be power of 2)
fn roundUp(offset: int, alignment: int) int {
    return ((offset + alignment - 1) / alignment) * alignment
}

fn funcBuilderBuild(fb: FuncBuilder) Func {
    // Collect params from locals
    var params: List<Local> = new List<Local>()
    var i: int = 0
    while i < len(fb.locals) {
        var local: Local = fb.locals.get(i)
        if local.is_param {
            params.push(local)
        }
        i = i + 1
    }

    // Compute stack frame layout
    var frame_offset: int = 0
    i = 0
    while i < len(fb.locals) {
        var local: Local = fb.locals.get(i)
        // Round up to 8-byte alignment
        frame_offset = roundUp(frame_offset, 8)
        // Assign offset (negative for rbp-relative)
        local.offset = 0 - frame_offset - local.size
        // Advance by variable size
        frame_offset = frame_offset + local.size
        i = i + 1
    }

    // Add space for struct return temps
    frame_offset = frame_offset + fb.max_call_ret_size

    // Round total frame size to 16-byte alignment
    var frame_size: int = roundUp(frame_offset, 16)

    return Func{
        .name = fb.name,
        .type_idx = fb.type_idx,
        .return_type = fb.return_type,
        .params = params,
        .locals = fb.locals,
        .blocks = fb.blocks,
        .entry = 0,
        .nodes = fb.nodes,
        .span_start = fb.span_start,
        .span_end = fb.span_end,
        .frame_size = frame_size,
    }
}

// =============================================================================
// IR Builder
// =============================================================================

struct IRBuilder {
    ir: IR,
    current_func: FuncBuilder,
    has_func: bool,
}

fn irBuilderInit() IRBuilder {
    return IRBuilder{
        .ir = irInit(),
        .current_func = funcBuilderInit("", 0, 0, 0, 0),
        .has_func = false,
    }
}

fn irBuilderStartFunc(b: *IRBuilder, name: string, type_idx: TypeIndex, return_type: TypeIndex, span_start: int, span_end: int) void {
    b.*.current_func = funcBuilderInit(name, type_idx, return_type, span_start, span_end)
    b.*.has_func = true
}

fn irBuilderEndFunc(b: *IRBuilder) void {
    if b.*.has_func {
        var func: Func = funcBuilderBuild(b.*.current_func)
        b.*.ir.funcs.push(func)
        b.*.has_func = false
    }
}

fn irBuilderAddGlobal(b: *IRBuilder, g: Global) void {
    b.*.ir.globals.push(g)
}

fn irBuilderAddStruct(b: *IRBuilder, s: StructDef) void {
    b.*.ir.structs.push(s)
}

fn irBuilderGetIR(b: IRBuilder) IR {
    return b.ir
}

// =============================================================================
// Simple test
// =============================================================================

fn main() int {
    // Test node creation
    var n: Node = nodeInit(Op.const_int, 5, 0, 10)
    n = nodeWithAux(n, 42)
    if n.op != Op.const_int {
        return 1
    }
    if n.aux != 42 {
        return 2
    }

    // Test op properties
    if not opIsTerminator(Op.ret) {
        return 3
    }
    if not opIsTerminator(Op.jump) {
        return 4
    }
    if opIsTerminator(Op.add) {
        return 5
    }
    if not opHasSideEffects(Op.call) {
        return 6
    }
    if opHasSideEffects(Op.add) {
        return 7
    }

    // Test block creation
    var block: Block = blockInit(0)
    if block.index != 0 {
        return 8
    }

    // Test local creation
    var local: Local = localInit("x", 5, 0, true)
    if local.name != "x" {
        return 9
    }
    if not local.mutable {
        return 10
    }

    // Test local with param
    var param: Local = localInitParam("a", 5, 0, 8)
    if not param.is_param {
        return 11
    }
    if param.size != 8 {
        return 12
    }

    // Test func builder
    var fb: FuncBuilder = funcBuilderInit("test_fn", 0, 5, 0, 100)
    var param_idx: int = funcBuilderAddParam(&fb, "x", 5, 8)
    if param_idx != 0 {
        return 13
    }

    var local_idx: int = funcBuilderAddLocal(&fb, "y", 5, true)
    if local_idx != 1 {
        return 14
    }

    // Test lookup
    var found_idx: int = funcBuilderLookupLocal(fb, "x")
    if found_idx != 0 {
        return 15
    }

    var not_found: int = funcBuilderLookupLocal(fb, "z")
    if not_found != -1 {
        return 16
    }

    // Test emitting nodes
    var load_x: NodeIndex = funcBuilderEmitLocalLoad(&fb, 0, 5, 0, 10)
    if load_x != 0 {
        return 17
    }

    var const_1: NodeIndex = funcBuilderEmitConstInt(&fb, 1, 5, 0, 10)
    var add_node: NodeIndex = funcBuilderEmitBinary(&fb, Op.add, load_x, const_1, 5, 0, 10)
    var ret_node: NodeIndex = funcBuilderEmitReturn(&fb, add_node, 0, 10)

    if ret_node != 3 {
        return 18
    }

    // Test building func - skip for now due to large struct return issues
    // var func: Func = funcBuilderBuild(fb)
    // if func.name != "test_fn" {
    //     return 19
    // }
    // if len(func.params) != 1 {
    //     return 20
    // }
    // if len(func.locals) != 2 {
    //     return 21
    // }
    // if len(func.nodes) != 4 {
    //     return 22
    // }

    // Test roundUp function
    if roundUp(0, 8) != 0 {
        return 23
    }
    if roundUp(1, 8) != 8 {
        return 24
    }
    if roundUp(8, 8) != 8 {
        return 25
    }
    if roundUp(9, 16) != 16 {
        return 26
    }

    // Skip IRBuilder tests that use funcBuilderBuild (large struct return issue)
    // TODO: Fix large struct returns in codegen

    // Test global
    var g: Global = globalInit("MAX_SIZE", 5, true, 0, 20)
    if g.name != "MAX_SIZE" {
        return 30
    }
    if not g.is_const {
        return 31
    }

    // Test struct def
    var sd: StructDef = structDefInit("Point", 100, 0, 30)
    if sd.name != "Point" {
        return 32
    }

    // Test branch accessors
    var branch_node: Node = nodeInit(Op.branch, 12, 0, 10)
    branch_node = nodeWithArg012(branch_node, 99, 1, 2)
    if nodeGetBranchCondition(branch_node) != 99 {
        return 33
    }
    if nodeGetBranchThenBlock(branch_node) != 1 {
        return 34
    }
    if nodeGetBranchElseBlock(branch_node) != 2 {
        return 35
    }

    // Test node arg getters
    var test_node: Node = nodeInit(Op.add, 5, 0, 10)
    test_node = nodeWithArg01(test_node, 10, 20)
    if nodeGetArg(test_node, 0) != 10 {
        return 36
    }
    if nodeGetArg(test_node, 1) != 20 {
        return 37
    }

    // Test nodeSetArg
    var mut_node: Node = nodeInit(Op.call, 5, 0, 10)
    nodeSetArg(&mut_node, 0, 100)
    nodeSetArg(&mut_node, 1, 200)
    if nodeGetArg(mut_node, 0) != 100 {
        return 38
    }
    if nodeGetArg(mut_node, 1) != 200 {
        return 39
    }

    return 42
}
