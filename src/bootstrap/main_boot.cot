// Main entry point for cot bootstrap compiler (cot0).
// This is the CLI entry point - handles arg parsing and delegates to driver.
//
// Pipeline: Source -> Parse -> Lower -> Codegen -> Object

// =============================================================================
// Imports
// =============================================================================

// Import order matters - avoid transitive duplicates
// parser_boot.cot imports source_boot.cot, scanner_boot.cot, token_boot.cot
// lower_boot.cot imports ir_boot.cot
// driver_boot.cot has the compilation pipeline
import "parser_boot.cot"
import "lower_boot.cot"
import "codegen/arm64_boot.cot"
import "codegen/object_boot.cot"
import "driver_boot.cot"

// =============================================================================
// Version and Constants
// =============================================================================

fn getVersionMajor() int { return 0 }
fn getVersionMinor() int { return 2 }
fn getVersionPatch() int { return 0 }

// =============================================================================
// String Helpers
// =============================================================================

// Compare two strings for equality
fn stringEquals(a: string, b: string) bool {
    if len(a) != len(b) {
        return false
    }
    var i: int = 0
    while i < len(a) {
        if a[i] != b[i] {
            return false
        }
        i = i + 1
    }
    return true
}

// Check if string starts with prefix
fn stringStartsWith(s: string, prefix: string) bool {
    if len(s) < len(prefix) {
        return false
    }
    var i: int = 0
    while i < len(prefix) {
        if s[i] != prefix[i] {
            return false
        }
        i = i + 1
    }
    return true
}

// Check if string ends with ".cot"
fn stringEndsCot(s: string) bool {
    if len(s) < 4 {
        return false
    }
    var suffix_start: int = len(s) - 4
    if s[suffix_start] != 46 { return false }      // '.'
    if s[suffix_start + 1] != 99 { return false }  // 'c'
    if s[suffix_start + 2] != 111 { return false } // 'o'
    if s[suffix_start + 3] != 116 { return false } // 't'
    return true
}

// Get substring from start to end (exclusive)
fn substring(s: string, start: int, end: int) string {
    // For bootstrap, we use a simple approach
    // In practice, this would need runtime support for string slicing
    return s  // TODO: implement properly
}

// =============================================================================
// Command Parsing
// =============================================================================

enum Command: u8 {
    build,
    version,
    help,
    unknown,
}

fn parseCommand(arg: string) Command {
    if stringEquals(arg, "build") {
        return Command.build
    }
    if stringEquals(arg, "version") {
        return Command.version
    }
    if stringEquals(arg, "help") {
        return Command.help
    }
    // If it ends with .cot, treat as build
    if stringEndsCot(arg) {
        return Command.build
    }
    return Command.unknown
}

// =============================================================================
// Build Options
// =============================================================================

struct BuildOptions {
    input_path: string,
    output_path: string,
    compile_only: bool,
    verbose: bool,
    debug_ir: bool,
    debug_ssa: bool,
    debug_codegen: bool,
    disasm: bool,
}

fn buildOptionsDefault() BuildOptions {
    return BuildOptions{
        .input_path = "",
        .output_path = "",
        .compile_only = false,
        .verbose = false,
        .debug_ir = false,
        .debug_ssa = false,
        .debug_codegen = false,
        .disasm = false,
    }
}

// Check if string is an option flag (starts with -)
fn isOptionFlag(arg: string) bool {
    if len(arg) == 0 {
        return false
    }
    return arg[0] == 45  // '-'
}

// Parse command line arguments into BuildOptions
fn parseBuildOptions() BuildOptions {
    var opts: BuildOptions = buildOptionsDefault()
    var argc: int = @argsCount()
    var i: int = 1  // Skip program name

    while i < argc {
        var arg: string = @argsGet(i)

        if stringEquals(arg, "-o") {
            // Next arg is output path
            i = i + 1
            if i < argc {
                opts.output_path = @argsGet(i)
            }
        } else if stringEquals(arg, "-c") {
            opts.compile_only = true
        } else if stringEquals(arg, "-v") or stringEquals(arg, "--verbose") {
            opts.verbose = true
        } else if stringEquals(arg, "--debug-ir") {
            opts.debug_ir = true
        } else if stringEquals(arg, "--debug-ssa") {
            opts.debug_ssa = true
        } else if stringEquals(arg, "--debug-codegen") {
            opts.debug_codegen = true
        } else if stringEquals(arg, "--disasm") {
            opts.disasm = true
        } else if not isOptionFlag(arg) {
            // Positional argument - input file
            if len(opts.input_path) == 0 {
                opts.input_path = arg
            }
        }

        i = i + 1
    }

    return opts
}

// =============================================================================
// NOTE: Compilation pipeline is now in driver_boot.cot
// Lowering is in lower_boot.cot
// Code generation is in driver_boot.cot (which uses codegen/*.cot)
// =============================================================================

// =============================================================================
// Main Entry Point
// =============================================================================

fn main() int {
    var argc: int = @argsCount()

    // Need at least program name and input file
    if argc < 2 {
        return 42  // Success - no file specified, but parser works
    }

    // Parse options
    var opts: BuildOptions = parseBuildOptions()

    if len(opts.input_path) == 0 {
        return 1  // Error: No input file specified
    }

    // Default output path if not specified
    var output_path: string = opts.output_path
    if len(output_path) == 0 {
        output_path = "a.out"
    }

    // Compile using driver
    var result: CompileResult = compileFile(opts.input_path, output_path)

    if result.success {
        return 0
    }
    return result.error_count
}
