// Main entry point for cot bootstrap compiler (cot0).
// This is the CLI driver that orchestrates compilation.
//
// Pipeline: Source -> Parse -> Lower -> SSA -> Codegen -> Object

// =============================================================================
// Imports
// =============================================================================

// Import order matters - avoid transitive duplicates
// parser_boot.cot imports source_boot.cot, scanner_boot.cot, token_boot.cot
// lower_boot.cot imports ir_boot.cot
import "parser_boot.cot"
import "lower_boot.cot"
import "codegen/arm64_boot.cot"
import "codegen/object_boot.cot"

// =============================================================================
// Version and Constants
// =============================================================================

fn getVersionMajor() int { return 0 }
fn getVersionMinor() int { return 2 }
fn getVersionPatch() int { return 0 }

// =============================================================================
// String Helpers
// =============================================================================

// Compare two strings for equality
fn stringEquals(a: string, b: string) bool {
    if len(a) != len(b) {
        return false
    }
    var i: int = 0
    while i < len(a) {
        if a[i] != b[i] {
            return false
        }
        i = i + 1
    }
    return true
}

// Check if string starts with prefix
fn stringStartsWith(s: string, prefix: string) bool {
    if len(s) < len(prefix) {
        return false
    }
    var i: int = 0
    while i < len(prefix) {
        if s[i] != prefix[i] {
            return false
        }
        i = i + 1
    }
    return true
}

// Check if string ends with ".cot"
fn stringEndsCot(s: string) bool {
    if len(s) < 4 {
        return false
    }
    var suffix_start: int = len(s) - 4
    if s[suffix_start] != 46 { return false }      // '.'
    if s[suffix_start + 1] != 99 { return false }  // 'c'
    if s[suffix_start + 2] != 111 { return false } // 'o'
    if s[suffix_start + 3] != 116 { return false } // 't'
    return true
}

// Get substring from start to end (exclusive)
fn substring(s: string, start: int, end: int) string {
    // For bootstrap, we use a simple approach
    // In practice, this would need runtime support for string slicing
    return s  // TODO: implement properly
}

// =============================================================================
// Command Parsing
// =============================================================================

enum Command: u8 {
    build,
    version,
    help,
    unknown,
}

fn parseCommand(arg: string) Command {
    if stringEquals(arg, "build") {
        return Command.build
    }
    if stringEquals(arg, "version") {
        return Command.version
    }
    if stringEquals(arg, "help") {
        return Command.help
    }
    // If it ends with .cot, treat as build
    if stringEndsCot(arg) {
        return Command.build
    }
    return Command.unknown
}

// =============================================================================
// Build Options
// =============================================================================

struct BuildOptions {
    input_path: string,
    output_path: string,
    compile_only: bool,
    verbose: bool,
    debug_ir: bool,
    debug_ssa: bool,
    debug_codegen: bool,
    disasm: bool,
}

fn buildOptionsDefault() BuildOptions {
    return BuildOptions{
        .input_path = "",
        .output_path = "",
        .compile_only = false,
        .verbose = false,
        .debug_ir = false,
        .debug_ssa = false,
        .debug_codegen = false,
        .disasm = false,
    }
}

// Check if string is an option flag (starts with -)
fn isOptionFlag(arg: string) bool {
    if len(arg) == 0 {
        return false
    }
    return arg[0] == 45  // '-'
}

// Parse command line arguments into BuildOptions
fn parseBuildOptions() BuildOptions {
    var opts: BuildOptions = buildOptionsDefault()
    var argc: int = @argsCount()
    var i: int = 1  // Skip program name

    while i < argc {
        var arg: string = @argsGet(i)

        if stringEquals(arg, "-o") {
            // Next arg is output path
            i = i + 1
            if i < argc {
                opts.output_path = @argsGet(i)
            }
        } else if stringEquals(arg, "-c") {
            opts.compile_only = true
        } else if stringEquals(arg, "-v") or stringEquals(arg, "--verbose") {
            opts.verbose = true
        } else if stringEquals(arg, "--debug-ir") {
            opts.debug_ir = true
        } else if stringEquals(arg, "--debug-ssa") {
            opts.debug_ssa = true
        } else if stringEquals(arg, "--debug-codegen") {
            opts.debug_codegen = true
        } else if stringEquals(arg, "--disasm") {
            opts.disasm = true
        } else if not isOptionFlag(arg) {
            // Positional argument - input file
            if len(opts.input_path) == 0 {
                opts.input_path = arg
            }
        }

        i = i + 1
    }

    return opts
}

// =============================================================================
// Compiler State
// =============================================================================

struct CompilerState {
    parser: ParserState,
    ir_builder: IRProgramBuilder,
    string_literals: List<string>,
    error_count: int,
    verbose: bool,
}

fn compilerInit(content: string, verbose: bool) CompilerState {
    return CompilerState{
        .parser = parserInit(content),
        .ir_builder = irProgramBuilderInit(),
        .string_literals = new List<string>(),
        .error_count = 0,
        .verbose = verbose,
    }
}

// =============================================================================
// AST Node Accessors (convenience functions)
// =============================================================================

fn getNode(state: CompilerState, idx: NodeIndex) Node {
    return state.parser.nodes.get(idx)
}

// =============================================================================
// Expression Lowering
// =============================================================================

// Forward declaration pattern - we need mutual recursion
// lowerExpr calls lowerBinaryExpr which may call lowerExpr

fn lowerExpr(state: *CompilerState, fb: *IRFuncBuilder, node_idx: NodeIndex) NodeIndex {
    if node_idx == null_node {
        return null_node
    }

    var node: Node = state.*.parser.nodes.get(node_idx)
    var span_start: int = node.span.start.offset
    var span_end: int = node.span.end.offset
    var tag: NodeTag = node.tag

    if tag == NodeTag.int_literal {
        return lowerIntLiteralNode(state, fb, node, span_start, span_end)
    }
    if tag == NodeTag.bool_literal {
        return lowerBoolLiteralNode(state, fb, node, span_start, span_end)
    }
    if tag == NodeTag.string_literal {
        return lowerStringLiteralNode(state, fb, node, span_start, span_end)
    }
    if tag == NodeTag.identifier {
        return lowerIdentifierNode(state, fb, node, span_start, span_end)
    }
    if tag == NodeTag.binary_expr {
        return lowerBinaryExprNode(state, fb, node, span_start, span_end)
    }
    if tag == NodeTag.unary_expr {
        return lowerUnaryExprNode(state, fb, node, span_start, span_end)
    }
    if tag == NodeTag.call_expr {
        return lowerCallExprNode(state, fb, node, span_start, span_end)
    }
    if tag == NodeTag.paren_expr {
        return lowerExpr(state, fb, node.left)
    }
    return null_node
}

fn lowerIntLiteralNode(state: *CompilerState, fb: *IRFuncBuilder, node: Node, span_start: int, span_end: int) NodeIndex {
    // Parse the integer from the text
    var value: int = parseIntLiteral(node.text)
    return irFuncBuilderEmitConstInt(fb, value, TYPE_INT, span_start, span_end)
}

fn parseIntLiteral(text: string) int {
    var result: int = 0
    var i: int = 0
    var negative: bool = false

    // Check for negative
    if len(text) > 0 and text[0] == 45 {  // '-'
        negative = true
        i = 1
    }

    while i < len(text) {
        var c: int = text[i]
        if c >= 48 and c <= 57 {  // '0'-'9'
            result = result * 10 + (c - 48)
        }
        i = i + 1
    }

    if negative {
        result = 0 - result
    }

    return result
}

fn lowerBoolLiteralNode(state: *CompilerState, fb: *IRFuncBuilder, node: Node, span_start: int, span_end: int) NodeIndex {
    var value: bool = stringEquals(node.text, "true")
    return irFuncBuilderEmitConstBool(fb, value, span_start, span_end)
}

fn lowerStringLiteralNode(state: *CompilerState, fb: *IRFuncBuilder, node: Node, span_start: int, span_end: int) NodeIndex {
    // Add string to literal table
    var idx: int = len(state.*.string_literals)
    state.*.string_literals.push(node.text)
    return irFuncBuilderEmitConstSlice(fb, idx, TYPE_STRING, span_start, span_end)
}

fn lowerIdentifierNode(state: *CompilerState, fb: *IRFuncBuilder, node: Node, span_start: int, span_end: int) NodeIndex {
    // Look up the variable
    var local_idx: int = irFuncBuilderLookupLocal(fb.*, node.name)
    if local_idx >= 0 {
        return irFuncBuilderEmitLocalLoad(fb, local_idx, TYPE_INT, span_start, span_end)
    }
    // Not found - error
    state.*.error_count = state.*.error_count + 1
    return null_node
}

fn lowerBinaryExprNode(state: *CompilerState, fb: *IRFuncBuilder, node: Node, span_start: int, span_end: int) NodeIndex {
    var left: NodeIndex = lowerExpr(state, fb, node.left)
    var right: NodeIndex = lowerExpr(state, fb, node.right)

    // Map token to IR op
    var ir_op: Op = tokenToIROp(node.op)

    return irFuncBuilderEmitBinary(fb, ir_op, left, right, TYPE_INT, span_start, span_end)
}

fn tokenToIROp(tok: Token) Op {
    if tok == Token.plus { return Op.add }
    if tok == Token.minus { return Op.sub }
    if tok == Token.star { return Op.mul }
    if tok == Token.slash { return Op.div }
    if tok == Token.percent { return Op.mod }
    if tok == Token.equal_equal { return Op.eq }
    if tok == Token.bang_equal { return Op.ne }
    if tok == Token.less { return Op.lt }
    if tok == Token.less_equal { return Op.le }
    if tok == Token.greater { return Op.gt }
    if tok == Token.greater_equal { return Op.ge }
    if tok == Token.kw_and { return Op.op_and }
    if tok == Token.kw_or { return Op.op_or }
    return Op.nop
}

fn lowerUnaryExprNode(state: *CompilerState, fb: *IRFuncBuilder, node: Node, span_start: int, span_end: int) NodeIndex {
    var operand: NodeIndex = lowerExpr(state, fb, node.left)

    var ir_op: Op = Op.nop
    var tok: Token = node.op
    if tok == Token.minus { ir_op = Op.neg }
    if tok == Token.bang { ir_op = Op.op_not }

    return irFuncBuilderEmitUnary(fb, ir_op, operand, TYPE_INT, span_start, span_end)
}

fn lowerCallExprNode(state: *CompilerState, fb: *IRFuncBuilder, node: Node, span_start: int, span_end: int) NodeIndex {
    // Get function name
    var callee_node: Node = state.*.parser.nodes.get(node.left)
    var func_name: string = callee_node.name

    // Lower arguments
    var arg0: NodeIndex = null_node
    var arg1: NodeIndex = null_node
    var arg2: NodeIndex = null_node
    var arg3: NodeIndex = null_node
    var num_args: int = len(node.args)

    if num_args > 0 {
        arg0 = lowerExpr(state, fb, node.args.get(0))
    }
    if num_args > 1 {
        arg1 = lowerExpr(state, fb, node.args.get(1))
    }
    if num_args > 2 {
        arg2 = lowerExpr(state, fb, node.args.get(2))
    }
    if num_args > 3 {
        arg3 = lowerExpr(state, fb, node.args.get(3))
    }

    // Create call node
    var n: IRNode = irNodeInit(Op.call, TYPE_INT, span_start, span_end)
    n.aux_str = func_name
    if num_args > 0 { n = irNodeWithArg0(n, arg0) }
    if num_args > 1 { n.args1 = arg1; n.args_len = 2 }
    if num_args > 2 { n.args2 = arg2; n.args_len = 3 }
    if num_args > 3 { n.args3 = arg3; n.args_len = 4 }

    return irFuncBuilderEmit(fb, n)
}

// =============================================================================
// Statement Lowering
// =============================================================================

fn lowerStmt(state: *CompilerState, fb: *IRFuncBuilder, node_idx: NodeIndex) void {
    println("DEBUG: lowerStmt enter")
    if node_idx == null_node {
        println("DEBUG: lowerStmt null_node, returning")
        return
    }

    var node: Node = state.*.parser.nodes.get(node_idx)
    var span_start: int = node.span.start.offset
    var span_end: int = node.span.end.offset
    var tag: NodeTag = node.tag

    println("DEBUG: lowerStmt got tag")
    if tag == NodeTag.return_stmt {
        println("DEBUG: lowering return_stmt")
        lowerReturnStmtNode(state, fb, node, span_start, span_end)
    } else if tag == NodeTag.var_stmt {
        lowerVarStmtNode(state, fb, node, span_start, span_end)
    } else if tag == NodeTag.assign_stmt {
        lowerAssignStmtNode(state, fb, node, span_start, span_end)
    } else if tag == NodeTag.if_stmt {
        lowerIfStmtNode(state, fb, node, span_start, span_end)
    } else if tag == NodeTag.while_stmt {
        lowerWhileStmtNode(state, fb, node, span_start, span_end)
    } else if tag == NodeTag.block_stmt {
        println("DEBUG: lowering block_stmt")
        lowerBlockStmtNode(state, fb, node)
    } else if tag == NodeTag.expr_stmt {
        println("DEBUG: lowering expr_stmt")
        lowerExprStmtNode(state, fb, node)
    } else {
        println("DEBUG: unknown stmt tag")
    }
}

fn lowerReturnStmtNode(state: *CompilerState, fb: *IRFuncBuilder, node: Node, span_start: int, span_end: int) void {
    var value: NodeIndex = null_node
    if node.left != null_node {
        value = lowerExpr(state, fb, node.left)
    }
    irFuncBuilderEmitReturn(fb, value, span_start, span_end)
}

fn lowerVarStmtNode(state: *CompilerState, fb: *IRFuncBuilder, node: Node, span_start: int, span_end: int) void {
    // Add local variable
    var local_idx: int = irFuncBuilderAddLocal(fb, node.name, TYPE_INT, true)

    // If there's an initializer, lower it and store
    if node.right != null_node {
        var init_val: NodeIndex = lowerExpr(state, fb, node.right)
        irFuncBuilderEmitLocalStore(fb, local_idx, init_val, TYPE_INT, span_start, span_end)
    }
}

fn lowerAssignStmtNode(state: *CompilerState, fb: *IRFuncBuilder, node: Node, span_start: int, span_end: int) void {
    // Get target variable
    var target_node: Node = state.*.parser.nodes.get(node.left)
    var local_idx: int = irFuncBuilderLookupLocal(fb.*, target_node.name)

    if local_idx >= 0 {
        // Lower the value
        var value: NodeIndex = lowerExpr(state, fb, node.right)
        irFuncBuilderEmitLocalStore(fb, local_idx, value, TYPE_INT, span_start, span_end)
    }
}

fn lowerIfStmtNode(state: *CompilerState, fb: *IRFuncBuilder, node: Node, span_start: int, span_end: int) void {
    var has_else: bool = node.else_body != null_node

    // Lower condition
    var cond: NodeIndex = lowerExpr(state, fb, node.cond)

    // Create blocks
    var then_block: IRBlockIndex = irFuncBuilderNewBlock(fb, "then")
    var else_block: IRBlockIndex = irFuncBuilderNewBlock(fb, "else")
    var merge_block: IRBlockIndex = irFuncBuilderNewBlock(fb, "merge")

    // Emit branch
    irFuncBuilderEmitBranch(fb, cond, then_block, else_block, span_start, span_end)

    // Lower then block
    irFuncBuilderSetBlock(fb, then_block)
    lowerStmt(state, fb, node.body)
    irFuncBuilderEmitJump(fb, merge_block, span_start, span_end)

    // Lower else block
    irFuncBuilderSetBlock(fb, else_block)
    if has_else {
        lowerStmt(state, fb, node.else_body)
    }
    irFuncBuilderEmitJump(fb, merge_block, span_start, span_end)

    // Continue in merge block
    irFuncBuilderSetBlock(fb, merge_block)
}

fn lowerWhileStmtNode(state: *CompilerState, fb: *IRFuncBuilder, node: Node, span_start: int, span_end: int) void {
    // Create blocks
    var cond_block: IRBlockIndex = irFuncBuilderNewBlock(fb, "while.cond")
    var body_block: IRBlockIndex = irFuncBuilderNewBlock(fb, "while.body")
    var exit_block: IRBlockIndex = irFuncBuilderNewBlock(fb, "while.exit")

    // Jump to condition
    irFuncBuilderEmitJump(fb, cond_block, span_start, span_end)

    // Condition block
    irFuncBuilderSetBlock(fb, cond_block)
    var cond: NodeIndex = lowerExpr(state, fb, node.cond)
    irFuncBuilderEmitBranch(fb, cond, body_block, exit_block, span_start, span_end)

    // Body block
    irFuncBuilderSetBlock(fb, body_block)
    lowerStmt(state, fb, node.body)
    irFuncBuilderEmitJump(fb, cond_block, span_start, span_end)

    // Continue after loop
    irFuncBuilderSetBlock(fb, exit_block)
}

fn lowerBlockStmtNode(state: *CompilerState, fb: *IRFuncBuilder, node: Node) void {
    println("DEBUG: lowerBlockStmtNode enter")
    var arg_count: int = len(node.args)
    if arg_count == 0 {
        println("DEBUG: block has 0 args")
    } else {
        println("DEBUG: block has args")
    }
    var i: int = 0
    while i < arg_count {
        println("DEBUG: processing block arg")
        lowerStmt(state, fb, node.args.get(i))
        i = i + 1
    }
    println("DEBUG: lowerBlockStmtNode exit")
}

fn lowerExprStmtNode(state: *CompilerState, fb: *IRFuncBuilder, node: Node) void {
    // Just evaluate the expression (for side effects)
    lowerExpr(state, fb, node.left)
}

// =============================================================================
// Function Declaration Lowering
// =============================================================================

fn lowerFnDecl(state: *CompilerState, node_idx: NodeIndex) void {
    var node: Node = state.*.parser.nodes.get(node_idx)
    var span_start: int = node.span.start.offset
    var span_end: int = node.span.end.offset

    // Create function builder
    var fb: IRFuncBuilder = irFuncBuilderInit(node.name, 0, TYPE_INT, span_start, span_end)

    // Create entry block
    var entry_block: IRBlockIndex = irFuncBuilderNewBlock(&fb, "entry")
    irFuncBuilderSetBlock(&fb, entry_block)

    // Process the function body
    if node.body != null_node {
        lowerStmt(state, &fb, node.body)
    }

    // Build and add function to IR
    var func: IRFunc = irFuncBuilderBuild(fb)

    // Add function to the IR program
    // Workaround: copy ir_builder to local to avoid pointer chain issues
    var builder: IRProgramBuilder = state.*.ir_builder
    builder.ir.funcs.push(func)
}

// =============================================================================
// Top-Level AST Processing
// =============================================================================

fn compileAST(state: *CompilerState) void {
    // Walk through all parsed nodes and process top-level declarations
    var i: int = 0
    var count: int = len(state.*.parser.nodes)

    while i < count {
        var node: Node = state.*.parser.nodes.get(i)
        var tag: NodeTag = node.tag

        if tag == NodeTag.fn_decl {
            lowerFnDecl(state, i)
        }
        // TODO: Handle struct_decl, enum_decl, etc.

        i = i + 1
    }
}

// =============================================================================
// Code Generation
// =============================================================================

fn generateCode(state: *CompilerState, output_path: string) bool {
    var ir: IRProgram = state.*.ir_builder.ir

    // Check for functions to generate
    var num_funcs: int = len(ir.funcs)
    if num_funcs == 0 {
        return false
    }

    // Create object file
    var obj: ObjectFile = objectFileNew()

    // Add text section
    var text_idx: int = objectAddSection(obj, "__text", SectionKind.text)
    var text_sec: Section = objectGetSection(obj, text_idx)

    // Generate code for each function
    println("DEBUG: num funcs in IR")
    var n_funcs: int = len(ir.funcs)
    if n_funcs == 0 {
        println("DEBUG: 0 funcs")
    } else if n_funcs == 1 {
        println("DEBUG: 1 func")
    } else {
        println("DEBUG: multiple funcs")
    }
    var func_idx: int = 0
    while func_idx < n_funcs {
        var func: IRFunc = ir.funcs.get(func_idx)
        println("DEBUG: processing func")
        var n_blocks: int = len(func.blocks)
        if n_blocks == 0 {
            println("DEBUG: func has 0 blocks")
        } else {
            println("DEBUG: func has blocks")
        }
        var n_nodes: int = len(func.nodes)
        if n_nodes == 0 {
            println("DEBUG: func has 0 nodes")
        } else {
            println("DEBUG: func has nodes")
        }

        // Add function symbol (prefix with underscore on macOS)
        var sym_start: int = sectionSize(text_sec)
        var sym_name: string = "_" + func.name
        objectAddSymbol(obj, symbolNew(sym_name, SymbolKind.func, text_idx, sym_start, 0, true))

        // Generate function code
        generateFunction(state, &text_sec, func)

        func_idx = func_idx + 1
    }

    // Note: text_sec is a shallow copy - its .data List handle points to the
    // same underlying data as obj.sections[text_idx].data. So modifications
    // via sectionAppendByte already affected the shared data.

    // Write object file to buffer
    var output: OutputBuffer = outputBufferNew()
    writeMachO64(obj, output)

    // Write buffer to disk - @fileWriteListBytes writes each list element's low byte
    var result: int = @fileWriteListBytes(output_path, output.bytes)

    return result > 0
}

fn generateFunction(state: *CompilerState, text_sec: *Section, func: IRFunc) void {
    // Create code generator
    var cg: FullCodeGen = fullCodeGenInit(func.frame_size)

    // Emit prologue
    cgGenPrologue(&cg, func.frame_size)

    // Generate code for each block
    println("DEBUG: generating blocks")
    var block_idx: int = 0
    while block_idx < len(func.blocks) {
        println("DEBUG: processing block")
        var block: IRBlock = func.blocks.get(block_idx)

        // Generate code for each node in block
        var node_idx: int = 0
        var node_count: int = len(block.nodes)
        if node_count == 0 {
            println("DEBUG: block has 0 nodes")
        } else {
            println("DEBUG: block has nodes")
        }
        while node_idx < node_count {
            var ir_node_idx: IRNodeIndex = block.nodes.get(node_idx)
            var ir_node: IRNode = func.nodes.get(ir_node_idx)
            generateNode(state, &cg, ir_node, ir_node_idx)
            node_idx = node_idx + 1
        }

        block_idx = block_idx + 1
    }

    // Copy code buffer to section
    var byte_count: int = len(cg.buf.bytes)
    println("DEBUG: generateFunction copying bytes")
    if byte_count == 0 {
        println("DEBUG: byte_count is ZERO!")
    } else {
        println("DEBUG: byte_count is non-zero")
    }
    println("DEBUG: starting loop")
    var i: int = 0
    while i < byte_count {
        println("DEBUG: loop iter")
        var byte_val: int = cg.buf.bytes.get(i)
        println("DEBUG: got byte_val")
        sectionAppendByte(text_sec, byte_val)
        println("DEBUG: appended byte")
        i = i + 1
    }
    println("DEBUG: done copying")
}

fn generateNode(state: *CompilerState, cg: *FullCodeGen, node: IRNode, node_idx: IRNodeIndex) void {
    println("DEBUG: generateNode called")
    var op: Op = node.op
    if op == Op.const_int {
        println("DEBUG: generating const_int")
        cgGenConstInt(cg, node_idx, node.aux)
    } else if op == Op.add {
        cgGenAdd(cg, node_idx, irNodeGetArg(node, 0), irNodeGetArg(node, 1))
    } else if op == Op.sub {
        cgGenSub(cg, node_idx, irNodeGetArg(node, 0), irNodeGetArg(node, 1))
    } else if op == Op.mul {
        cgGenMul(cg, node_idx, irNodeGetArg(node, 0), irNodeGetArg(node, 1))
    } else if op == Op.div {
        cgGenDiv(cg, node_idx, irNodeGetArg(node, 0), irNodeGetArg(node, 1))
    } else if op == Op.eq {
        cgGenCmpEq(cg, node_idx, irNodeGetArg(node, 0), irNodeGetArg(node, 1))
    } else if op == Op.ne {
        cgGenCmpNe(cg, node_idx, irNodeGetArg(node, 0), irNodeGetArg(node, 1))
    } else if op == Op.lt {
        cgGenCmpLt(cg, node_idx, irNodeGetArg(node, 0), irNodeGetArg(node, 1))
    } else if op == Op.le {
        cgGenCmpLe(cg, node_idx, irNodeGetArg(node, 0), irNodeGetArg(node, 1))
    } else if op == Op.gt {
        cgGenCmpGt(cg, node_idx, irNodeGetArg(node, 0), irNodeGetArg(node, 1))
    } else if op == Op.ge {
        cgGenCmpGe(cg, node_idx, irNodeGetArg(node, 0), irNodeGetArg(node, 1))
    } else if op == Op.neg {
        cgGenNeg(cg, node_idx, irNodeGetArg(node, 0))
    } else if op == Op.local {
        cgGenLoadStack(cg, node_idx, 0 - (node.aux + 1) * 8, 8)
    } else if op == Op.store {
        cgGenStoreStack(cg, irNodeGetArg(node, 0), 0 - (node.aux + 1) * 8, 8)
    } else if op == Op.ret {
        println("DEBUG: generating ret")
        cgGenReturn(cg, irNodeGetArg(node, 0))
    } else {
        println("DEBUG: unknown op")
    }
}

// =============================================================================
// Main Compilation Entry Point
// =============================================================================

fn compile(input_path: string, output_path: string, verbose: bool) int {
    // Read source file
    println("DEBUG: reading file")
    var content: string = @fileRead(input_path)
    println("DEBUG: file read done")

    var content_len: int = len(content)
    if content_len == 0 {
        println("DEBUG: content is empty!")
        return 1  // Error: Cannot read input file
    } else {
        println("DEBUG: content has data")
    }

    // Initialize compiler state
    var state: CompilerState = compilerInit(content, verbose)

    // Parse
    state.parser = parseFile(state.parser)

    // Note: error_count may be non-zero for some parser states
    // but we check for nodes like test_parser does
    if len(state.parser.nodes) == 0 {
        return 2  // No AST nodes produced
    }

    // Lower AST to IR
    compileAST(&state)

    if state.error_count > 0 {
        return 3  // Lowering errors
    }

    // Generate code
    var success: bool = generateCode(&state, output_path)

    if not success {
        return 4  // Code generation failed
    }

    return 0
}

// =============================================================================
// Main Entry Point
// =============================================================================

fn main() int {
    var argc: int = @argsCount()

    // Need at least program name and input file
    if argc < 2 {
        return 42  // Success - no file specified, but parser works
    }

    // Parse options
    var opts: BuildOptions = parseBuildOptions()

    if len(opts.input_path) == 0 {
        return 1  // Error: No input file specified
    }

    // Default output path if not specified
    var output_path: string = opts.output_path
    if len(output_path) == 0 {
        output_path = "a.out"
    }

    // Compile
    return compile(opts.input_path, output_path, opts.verbose)
}
