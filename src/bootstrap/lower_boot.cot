// AST-to-IR lowering pass for cot bootstrap.
import "ir_boot.cot"

// Pre-defined type indices (must match types_boot.cot)
const TYPE_VOID: TypeIndex = 12
const TYPE_BOOL: TypeIndex = 1
const TYPE_INT: TypeIndex = 5
const TYPE_I64: TypeIndex = 5
const TYPE_U8: TypeIndex = 6
const TYPE_STRING: TypeIndex = 13
const TYPE_FLOAT: TypeIndex = 11
const TYPE_INVALID: TypeIndex = 0

// =============================================================================
// Loop Context (for break/continue)
// =============================================================================

struct LoopContext {
    cond_block: IRBlockIndex,
    exit_block: IRBlockIndex,
}

// =============================================================================
// Lowerer State
// =============================================================================

struct Lowerer {
    // Current function being lowered
    current_func_name: string,
    has_current_func: bool,

    // String literals collected during lowering
    string_literals: List<string>,

    // Loop context stack for break/continue
    loop_stack: List<LoopContext>,

    // Compile-time constant values
    const_values: Map<string, int>,

    // For-loop counter for unique names
    for_counter: int,
}

fn lowererInit() Lowerer {
    return Lowerer{
        .current_func_name = "",
        .has_current_func = false,
        .string_literals = new List<string>(),
        .loop_stack = new List<LoopContext>(),
        .const_values = new Map<string, int>(),
        .for_counter = 0,
    }
}

fn lowererAddStringLiteral(l: *Lowerer, str: string) int {
    var idx: int = len(l.*.string_literals)
    l.*.string_literals.push(str)
    return idx
}

fn lowererPushLoop(l: *Lowerer, cond_block: IRBlockIndex, exit_block: IRBlockIndex) void {
    l.*.loop_stack.push(LoopContext{ .cond_block = cond_block, .exit_block = exit_block })
}

fn lowererPopLoop(l: *Lowerer) void {
    // Pop by removing last element - simplified for bootstrap
    // (Real impl would use a proper pop operation)
}

fn lowererCurrentLoop(l: Lowerer) LoopContext {
    if len(l.loop_stack) == 0 {
        return LoopContext{ .cond_block = ir_null_block, .exit_block = ir_null_block }
    }
    return l.loop_stack.get(len(l.loop_stack) - 1)
}

// =============================================================================
// Statement Lowering Helpers
// =============================================================================

struct IfBlocks {
    then_block: IRBlockIndex,
    else_block: IRBlockIndex,
    merge_block: IRBlockIndex,
    cond_node: IRNodeIndex,
}

struct WhileBlocks {
    cond_block: IRBlockIndex,
    body_block: IRBlockIndex,
    exit_block: IRBlockIndex,
}

struct ForBlocks {
    cond_block: IRBlockIndex,
    body_block: IRBlockIndex,
    incr_block: IRBlockIndex,
    exit_block: IRBlockIndex,
    idx_local: int,
    item_local: int,
    arr_len: int,
}

// =============================================================================
// Declaration Lowering
// =============================================================================

fn lowerVarStmt(l: *Lowerer, fb: *IRFuncBuilder, name: string, type_idx: TypeIndex, value_node: IRNodeIndex, is_mutable: bool, size: int) void {
    var local_idx: int = irFuncBuilderAddLocalWithSize(fb, name, type_idx, is_mutable, size)
    if value_node != ir_null_node {
        var store: IRNode = irNodeInit(Op.store, type_idx, 0, 0)
        store = irNodeWithArg01(store, local_idx, value_node)
        irFuncBuilderEmit(fb, store)
    }
}

fn lowerVarDecl(l: *Lowerer, builder: *IRProgramBuilder, name: string, type_idx: TypeIndex, is_const: bool, span_start: int, span_end: int) void {
    var g: IRGlobal = irGlobalInit(name, type_idx, is_const, span_start, span_end)
    irProgramBuilderAddGlobal(builder, g)
}

fn lowerConstDecl(l: *Lowerer, builder: *IRProgramBuilder, name: string, type_idx: TypeIndex, value: int, span_start: int, span_end: int) void {
    l.*.const_values.set(name, value)
    var g: IRGlobal = irGlobalInit(name, type_idx, true, span_start, span_end)
    irProgramBuilderAddGlobal(builder, g)
}

fn lowerStructDecl(l: *Lowerer, builder: *IRProgramBuilder, name: string, type_idx: TypeIndex, span_start: int, span_end: int) void {
    var sd: IRStructDef = irStructDefInit(name, type_idx, span_start, span_end)
    irProgramBuilderAddStruct(builder, sd)
}

// =============================================================================
// Statement Lowering
// =============================================================================

fn lowerReturn(l: *Lowerer, fb: *IRFuncBuilder, value_node: IRNodeIndex, return_type: TypeIndex, span_start: int, span_end: int) void {
    var ret: IRNode = irNodeInit(Op.ret, return_type, span_start, span_end)
    if value_node != ir_null_node {
        ret = irNodeWithArg0(ret, value_node)
    }
    irFuncBuilderEmit(fb, ret)
}

fn lowerAssign(l: *Lowerer, fb: *IRFuncBuilder, local_idx: int, value_node: IRNodeIndex, type_idx: TypeIndex, span_start: int, span_end: int) void {
    var store: IRNode = irNodeInit(Op.store, type_idx, span_start, span_end)
    store = irNodeWithArg01(store, local_idx, value_node)
    irFuncBuilderEmit(fb, store)
}

fn lowerCompoundAssign(l: *Lowerer, fb: *IRFuncBuilder, local_idx: int, op: Op, rhs: IRNodeIndex, type_idx: TypeIndex, span_start: int, span_end: int) void {
    var load: IRNode = irNodeInit(Op.load, type_idx, span_start, span_end)
    load = irNodeWithArg0(load, local_idx)
    var current_value: IRNodeIndex = irFuncBuilderEmit(fb, load)

    var bin: IRNode = irNodeInit(op, type_idx, span_start, span_end)
    bin = irNodeWithArg01(bin, current_value, rhs)
    var result: IRNodeIndex = irFuncBuilderEmit(fb, bin)

    var store: IRNode = irNodeInit(Op.store, type_idx, span_start, span_end)
    store = irNodeWithArg01(store, local_idx, result)
    irFuncBuilderEmit(fb, store)
}

fn lowerIfSetup(l: *Lowerer, fb: *IRFuncBuilder, cond_node: IRNodeIndex, has_else: bool, span_start: int, span_end: int) IfBlocks {
    var then_block: IRBlockIndex = irFuncBuilderNewBlock(fb, "if.then")
    var merge_block: IRBlockIndex = irFuncBuilderNewBlock(fb, "if.merge")
    var else_block: IRBlockIndex = ir_null_block
    if has_else {
        else_block = irFuncBuilderNewBlock(fb, "if.else")
    }
    return IfBlocks{
        .then_block = then_block,
        .else_block = else_block,
        .merge_block = merge_block,
        .cond_node = cond_node,
    }
}

fn lowerIfEmitBranch(l: *Lowerer, fb: *IRFuncBuilder, blocks: IfBlocks, span_start: int, span_end: int) void {
    var else_target: IRBlockIndex = blocks.else_block
    if else_target == ir_null_block {
        else_target = blocks.merge_block
    }
    irFuncBuilderEmitBranch(fb, blocks.cond_node, blocks.then_block, else_target, span_start, span_end)
}

fn lowerWhileSetup(l: *Lowerer, fb: *IRFuncBuilder, span_start: int, span_end: int) WhileBlocks {
    var cond_block: IRBlockIndex = irFuncBuilderNewBlock(fb, "while.cond")
    var body_block: IRBlockIndex = irFuncBuilderNewBlock(fb, "while.body")
    var exit_block: IRBlockIndex = irFuncBuilderNewBlock(fb, "while.exit")

    lowererPushLoop(l, cond_block, exit_block)
    irFuncBuilderEmitJump(fb, cond_block, span_start, span_end)

    return WhileBlocks{
        .cond_block = cond_block,
        .body_block = body_block,
        .exit_block = exit_block,
    }
}

fn lowerWhileEmitBranch(l: *Lowerer, fb: *IRFuncBuilder, blocks: WhileBlocks, cond_node: IRNodeIndex, span_start: int, span_end: int) void {
    var branch: IRNode = irNodeInit(Op.branch, TYPE_VOID, span_start, span_end)
    branch = irNodeWithArg012(branch, cond_node, blocks.body_block, blocks.exit_block)
    irFuncBuilderEmit(fb, branch)
}

fn lowerWhileFinish(l: *Lowerer, fb: *IRFuncBuilder, blocks: WhileBlocks, span_start: int, span_end: int) void {
    irFuncBuilderEmitJump(fb, blocks.cond_block, span_start, span_end)
    lowererPopLoop(l)
    irFuncBuilderSetBlock(fb, blocks.exit_block)
}

fn lowerBreak(l: *Lowerer, fb: *IRFuncBuilder, span_start: int, span_end: int) void {
    var loop_ctx: LoopContext = lowererCurrentLoop(l.*)
    if loop_ctx.exit_block != ir_null_block {
        irFuncBuilderEmitJump(fb, loop_ctx.exit_block, span_start, span_end)
    }
}

fn lowerContinue(l: *Lowerer, fb: *IRFuncBuilder, span_start: int, span_end: int) void {
    var loop_ctx: LoopContext = lowererCurrentLoop(l.*)
    if loop_ctx.cond_block != ir_null_block {
        irFuncBuilderEmitJump(fb, loop_ctx.cond_block, span_start, span_end)
    }
}

// =============================================================================
// Expression Lowering
// =============================================================================

fn lowerIdentifier(l: *Lowerer, fb: *IRFuncBuilder, name: string, type_idx: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var local_idx: int = irFuncBuilderLookupLocal(fb.*, name)
    if local_idx != -1 {
        var load: IRNode = irNodeInit(Op.load, type_idx, span_start, span_end)
        load = irNodeWithArg0(load, local_idx)
        return irFuncBuilderEmit(fb, load)
    }

    if l.*.const_values.has(name) {
        var value: int = l.*.const_values.get(name)
        var n: IRNode = irNodeInit(Op.const_int, TYPE_INT, span_start, span_end)
        n = irNodeWithAux(n, value)
        return irFuncBuilderEmit(fb, n)
    }

    return ir_null_node
}

fn lowerIntLiteral(l: *Lowerer, fb: *IRFuncBuilder, value: int, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.const_int, TYPE_INT, span_start, span_end)
    n = irNodeWithAux(n, value)
    return irFuncBuilderEmit(fb, n)
}

fn lowerBoolLiteral(l: *Lowerer, fb: *IRFuncBuilder, value: bool, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.const_bool, TYPE_BOOL, span_start, span_end)
    if value {
        n = irNodeWithAux(n, 1)
    } else {
        n = irNodeWithAux(n, 0)
    }
    return irFuncBuilderEmit(fb, n)
}

fn lowerStringLiteral(l: *Lowerer, fb: *IRFuncBuilder, str: string, span_start: int, span_end: int) IRNodeIndex {
    var string_idx: int = lowererAddStringLiteral(l, str)
    var n: IRNode = irNodeInit(Op.const_slice, TYPE_STRING, span_start, span_end)
    n = irNodeWithAux(n, string_idx)
    return irFuncBuilderEmit(fb, n)
}

fn lowerBinary(l: *Lowerer, fb: *IRFuncBuilder, op: Op, left: IRNodeIndex, right: IRNodeIndex, result_type: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(op, result_type, span_start, span_end)
    n = irNodeWithArg01(n, left, right)
    return irFuncBuilderEmit(fb, n)
}

fn lowerUnary(l: *Lowerer, fb: *IRFuncBuilder, op: Op, operand: IRNodeIndex, result_type: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(op, result_type, span_start, span_end)
    n = irNodeWithArg0(n, operand)
    return irFuncBuilderEmit(fb, n)
}

fn lowerCall(l: *Lowerer, fb: *IRFuncBuilder, func_name: string, arg0: IRNodeIndex, arg1: IRNodeIndex, arg2: IRNodeIndex, arg3: IRNodeIndex, num_args: int, return_type: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.call, return_type, span_start, span_end)
    n = irNodeWithAuxStr(n, func_name)
    if num_args >= 1 { n.args0 = arg0 }
    if num_args >= 2 { n.args1 = arg1 }
    if num_args >= 3 { n.args2 = arg2 }
    if num_args >= 4 { n.args3 = arg3 }
    n.args_len = num_args
    return irFuncBuilderEmit(fb, n)
}

fn lowerFieldAccess(l: *Lowerer, fb: *IRFuncBuilder, base_local: int, field_offset: int, field_type: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.field_local, field_type, span_start, span_end)
    n = irNodeWithArg0(n, base_local)
    n = irNodeWithAux(n, field_offset)
    return irFuncBuilderEmit(fb, n)
}

fn lowerFieldValue(l: *Lowerer, fb: *IRFuncBuilder, base_node: IRNodeIndex, field_offset: int, field_type: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.field_value, field_type, span_start, span_end)
    n = irNodeWithArg0(n, base_node)
    n = irNodeWithAux(n, field_offset)
    return irFuncBuilderEmit(fb, n)
}

fn lowerIndex(l: *Lowerer, fb: *IRFuncBuilder, base_local: int, index_node: IRNodeIndex, elem_type: TypeIndex, elem_size: int, is_slice: bool, span_start: int, span_end: int) IRNodeIndex {
    if is_slice {
        var n: IRNode = irNodeInit(Op.slice_index, elem_type, span_start, span_end)
        n = irNodeWithArg01(n, base_local, index_node)
        n = irNodeWithAux(n, elem_size)
        return irFuncBuilderEmit(fb, n)
    } else {
        var n: IRNode = irNodeInit(Op.addr_index, elem_type, span_start, span_end)
        n = irNodeWithArg01(n, base_local, index_node)
        n = irNodeWithAux(n, elem_size)
        return irFuncBuilderEmit(fb, n)
    }
}

fn lowerSliceExpr(l: *Lowerer, fb: *IRFuncBuilder, base_local: int, start_node: IRNodeIndex, end_node: IRNodeIndex, slice_type: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.slice_local, slice_type, span_start, span_end)
    n = irNodeWithArg012(n, base_local, start_node, end_node)
    return irFuncBuilderEmit(fb, n)
}

fn lowerAddrOf(l: *Lowerer, fb: *IRFuncBuilder, local_idx: int, ptr_type: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.addr_local, ptr_type, span_start, span_end)
    n = irNodeWithAux(n, local_idx)
    return irFuncBuilderEmit(fb, n)
}

fn lowerDeref(l: *Lowerer, fb: *IRFuncBuilder, ptr_node: IRNodeIndex, elem_type: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.ptr_load, elem_type, span_start, span_end)
    n = irNodeWithArg0(n, ptr_node)
    return irFuncBuilderEmit(fb, n)
}

fn lowerStructInit(l: *Lowerer, fb: *IRFuncBuilder, struct_type: TypeIndex, struct_size: int, span_start: int, span_end: int) int {
    var temp_local: int = irFuncBuilderAddLocalWithSize(fb, "__struct_tmp", struct_type, false, struct_size)
    return temp_local
}

fn lowerStructInitField(l: *Lowerer, fb: *IRFuncBuilder, local_idx: int, field_offset: int, value_node: IRNodeIndex, field_type: TypeIndex, span_start: int, span_end: int) void {
    var store: IRNode = irNodeInit(Op.store, field_type, span_start, span_end)
    store = irNodeWithArg01(store, local_idx, value_node)
    store = irNodeWithAux(store, field_offset)
    irFuncBuilderEmit(fb, store)
}

fn lowerStructInitFinish(l: *Lowerer, fb: *IRFuncBuilder, local_idx: int, struct_type: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var load: IRNode = irNodeInit(Op.load, struct_type, span_start, span_end)
    load = irNodeWithArg0(load, local_idx)
    return irFuncBuilderEmit(fb, load)
}

fn lowerIfExpr(l: *Lowerer, fb: *IRFuncBuilder, cond: IRNodeIndex, then_val: IRNodeIndex, else_val: IRNodeIndex, result_type: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.select, result_type, span_start, span_end)
    n = irNodeWithArg012(n, cond, then_val, else_val)
    return irFuncBuilderEmit(fb, n)
}

// =============================================================================
// Map/List Operations
// =============================================================================

fn lowerMapNew(l: *Lowerer, fb: *IRFuncBuilder, map_type: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.map_new, map_type, span_start, span_end)
    return irFuncBuilderEmit(fb, n)
}

fn lowerMapSet(l: *Lowerer, fb: *IRFuncBuilder, map_handle: IRNodeIndex, key_node: IRNodeIndex, value_node: IRNodeIndex, key_type: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.map_set, TYPE_VOID, span_start, span_end)
    n = irNodeWithArg012(n, map_handle, key_node, value_node)
    irNodeSetArg(&n, 3, key_type)
    n.args_len = 4
    return irFuncBuilderEmit(fb, n)
}

fn lowerMapGet(l: *Lowerer, fb: *IRFuncBuilder, map_handle: IRNodeIndex, key_node: IRNodeIndex, value_type: TypeIndex, key_type: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.map_get, value_type, span_start, span_end)
    n = irNodeWithArg01(n, map_handle, key_node)
    n = irNodeWithAux(n, key_type)
    return irFuncBuilderEmit(fb, n)
}

fn lowerMapHas(l: *Lowerer, fb: *IRFuncBuilder, map_handle: IRNodeIndex, key_node: IRNodeIndex, key_type: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.map_has, TYPE_BOOL, span_start, span_end)
    n = irNodeWithArg01(n, map_handle, key_node)
    n = irNodeWithAux(n, key_type)
    return irFuncBuilderEmit(fb, n)
}

fn lowerMapSize(l: *Lowerer, fb: *IRFuncBuilder, map_handle: IRNodeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.map_size, TYPE_INT, span_start, span_end)
    n = irNodeWithArg0(n, map_handle)
    return irFuncBuilderEmit(fb, n)
}

fn lowerListNew(l: *Lowerer, fb: *IRFuncBuilder, list_type: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.list_new, list_type, span_start, span_end)
    return irFuncBuilderEmit(fb, n)
}

fn lowerListPush(l: *Lowerer, fb: *IRFuncBuilder, list_handle: IRNodeIndex, value_node: IRNodeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.list_push, TYPE_VOID, span_start, span_end)
    n = irNodeWithArg01(n, list_handle, value_node)
    return irFuncBuilderEmit(fb, n)
}

fn lowerListGet(l: *Lowerer, fb: *IRFuncBuilder, list_handle: IRNodeIndex, index_node: IRNodeIndex, elem_type: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.list_get, elem_type, span_start, span_end)
    n = irNodeWithArg01(n, list_handle, index_node)
    return irFuncBuilderEmit(fb, n)
}

fn lowerListLen(l: *Lowerer, fb: *IRFuncBuilder, list_handle: IRNodeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.list_len, TYPE_INT, span_start, span_end)
    n = irNodeWithArg0(n, list_handle)
    return irFuncBuilderEmit(fb, n)
}

// =============================================================================
// Union Operations
// =============================================================================

fn lowerUnionInit(l: *Lowerer, fb: *IRFuncBuilder, union_type: TypeIndex, variant_idx: int, payload_node: IRNodeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.union_init, union_type, span_start, span_end)
    n = irNodeWithAux(n, variant_idx)
    if payload_node != ir_null_node {
        n = irNodeWithArg0(n, payload_node)
    }
    return irFuncBuilderEmit(fb, n)
}

fn lowerUnionTag(l: *Lowerer, fb: *IRFuncBuilder, union_node: IRNodeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.union_tag, TYPE_U8, span_start, span_end)
    n = irNodeWithArg0(n, union_node)
    return irFuncBuilderEmit(fb, n)
}

fn lowerUnionPayload(l: *Lowerer, fb: *IRFuncBuilder, union_node: IRNodeIndex, variant_idx: int, payload_type: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.union_payload, payload_type, span_start, span_end)
    n = irNodeWithArg0(n, union_node)
    n = irNodeWithAux(n, variant_idx)
    return irFuncBuilderEmit(fb, n)
}

// =============================================================================
// Builtin Functions
// =============================================================================

fn lowerLenArray(l: *Lowerer, fb: *IRFuncBuilder, arr_len: int, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.const_int, TYPE_INT, span_start, span_end)
    n = irNodeWithAux(n, arr_len)
    return irFuncBuilderEmit(fb, n)
}

fn lowerLenSlice(l: *Lowerer, fb: *IRFuncBuilder, slice_local: int, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.field, TYPE_INT, span_start, span_end)
    n = irNodeWithArg0(n, slice_local)
    n = irNodeWithAux(n, 8)
    return irFuncBuilderEmit(fb, n)
}

fn lowerMaxInt(l: *Lowerer, fb: *IRFuncBuilder, type_idx: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var max_value: int = 0
    if type_idx == 2 { max_value = 127 }
    if type_idx == 3 { max_value = 32767 }
    if type_idx == 4 { max_value = 2147483647 }
    if type_idx == 5 { max_value = @maxInt(i64) }
    if type_idx == 6 { max_value = 255 }
    if type_idx == 7 { max_value = 65535 }
    if type_idx == 8 { max_value = 4294967295 }
    var n: IRNode = irNodeInit(Op.const_int, TYPE_I64, span_start, span_end)
    n = irNodeWithAux(n, max_value)
    return irFuncBuilderEmit(fb, n)
}

fn lowerMinInt(l: *Lowerer, fb: *IRFuncBuilder, type_idx: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var min_value: int = 0
    if type_idx == 2 { min_value = -128 }
    if type_idx == 3 { min_value = -32768 }
    if type_idx == 4 { min_value = -2147483648 }
    if type_idx == 5 { min_value = @minInt(i64) }
    var n: IRNode = irNodeInit(Op.const_int, TYPE_I64, span_start, span_end)
    n = irNodeWithAux(n, min_value)
    return irFuncBuilderEmit(fb, n)
}

fn lowerPrint(l: *Lowerer, fb: *IRFuncBuilder, arg_node: IRNodeIndex, is_println: bool, span_start: int, span_end: int) IRNodeIndex {
    var func_name: string = "print"
    if is_println {
        func_name = "println"
    }
    var n: IRNode = irNodeInit(Op.call, TYPE_VOID, span_start, span_end)
    n = irNodeWithArg0(n, arg_node)
    n = irNodeWithAuxStr(n, func_name)
    n.args_len = 1
    return irFuncBuilderEmit(fb, n)
}

// =============================================================================
// Pointer Operations
// =============================================================================

fn lowerPtrStore(l: *Lowerer, fb: *IRFuncBuilder, ptr_node: IRNodeIndex, value_node: IRNodeIndex, elem_type: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.ptr_store, elem_type, span_start, span_end)
    n = irNodeWithArg01(n, ptr_node, value_node)
    return irFuncBuilderEmit(fb, n)
}

fn lowerPtrField(l: *Lowerer, fb: *IRFuncBuilder, local_idx: int, field_offset: int, field_type: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.ptr_field, field_type, span_start, span_end)
    n = irNodeWithArg0(n, local_idx)
    n = irNodeWithAux(n, field_offset)
    return irFuncBuilderEmit(fb, n)
}

fn lowerPtrFieldStore(l: *Lowerer, fb: *IRFuncBuilder, local_idx: int, field_offset: int, value_node: IRNodeIndex, field_type: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.ptr_field_store, field_type, span_start, span_end)
    n = irNodeWithArg01(n, local_idx, value_node)
    n = irNodeWithAux(n, field_offset)
    return irFuncBuilderEmit(fb, n)
}

fn lowerStrConcat(l: *Lowerer, fb: *IRFuncBuilder, left: IRNodeIndex, right: IRNodeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.str_concat, TYPE_STRING, span_start, span_end)
    n = irNodeWithArg01(n, left, right)
    return irFuncBuilderEmit(fb, n)
}

// =============================================================================
// Simple Test
// =============================================================================

fn test_lower() int {
    // Test lowerer initialization
    var l: Lowerer = lowererInit()
    if l.for_counter != 0 {
        return 1
    }

    // Test string literal addition
    var str_idx: int = lowererAddStringLiteral(&l, "hello")
    if str_idx != 0 {
        return 2
    }
    var str_idx2: int = lowererAddStringLiteral(&l, "world")
    if str_idx2 != 1 {
        return 3
    }

    // Test loop context
    lowererPushLoop(&l, 10, 20)
    var ctx: LoopContext = lowererCurrentLoop(l)
    if ctx.cond_block != 10 {
        return 4
    }
    if ctx.exit_block != 20 {
        return 5
    }

    // Test const values
    l.const_values.set("MAX", 100)
    if not l.const_values.has("MAX") {
        return 6
    }
    if l.const_values.get("MAX") != 100 {
        return 7
    }

    // Test Node creation
    var n: IRNode = irNodeInit(Op.const_int, TYPE_INT, 0, 10)
    n = irNodeWithAux(n, 42)
    if n.op != Op.const_int {
        return 8
    }
    if n.aux != 42 {
        return 9
    }

    // Test nodeWithArg functions
    var n2: IRNode = irNodeInit(Op.add, TYPE_INT, 0, 10)
    n2 = irNodeWithArg01(n2, 10, 20)
    if irNodeGetArg(n2, 0) != 10 {
        return 10
    }
    if irNodeGetArg(n2, 1) != 20 {
        return 11
    }

    // Test Local creation
    var local: IRLocal = irLocalInit("x", TYPE_INT, 0, true)
    if local.name != "x" {
        return 12
    }
    if not local.mutable {
        return 13
    }

    // Test irLocalInitWithSize
    var local2: IRLocal = irLocalInitWithSize("y", TYPE_INT, 1, false, 16)
    if local2.size != 16 {
        return 14
    }

    // Test Block creation
    var block: IRBlock = irBlockInit(0)
    if block.index != 0 {
        return 15
    }

    // Test Global creation
    var g: IRGlobal = irGlobalInit("MAX_VALUE", TYPE_INT, true, 0, 10)
    if g.name != "MAX_VALUE" {
        return 16
    }
    if not g.is_const {
        return 17
    }

    // Test StructDef creation
    var sd: IRStructDef = irStructDefInit("Point", 100, 0, 30)
    if sd.name != "Point" {
        return 18
    }

    // Test IfBlocks struct
    var if_blocks: IfBlocks = IfBlocks{
        .then_block = 1,
        .else_block = 2,
        .merge_block = 3,
        .cond_node = 0,
    }
    if if_blocks.then_block != 1 {
        return 19
    }

    // Test WhileBlocks struct
    var while_blocks: WhileBlocks = WhileBlocks{
        .cond_block = 10,
        .body_block = 11,
        .exit_block = 12,
    }
    if while_blocks.cond_block != 10 {
        return 20
    }

    // All tests pass
    return 42
}
