// AST-to-IR lowering pass for cot bootstrap.
// This module converts AST nodes (from parser) into IR (for codegen).
//
// Note: This module depends on types from parser_boot.cot (Node, NodeTag, Token).
// main_boot.cot imports parser_boot.cot before lower_boot.cot, so those types
// are available via transitive imports. We don't import parser_boot.cot directly
// to avoid duplicate definitions.
import "ir_boot.cot"

// Pre-defined type indices (must match types_boot.cot)
const TYPE_VOID: TypeIndex = 12
const TYPE_BOOL: TypeIndex = 1
const TYPE_INT: TypeIndex = 5
const TYPE_I64: TypeIndex = 5
const TYPE_U8: TypeIndex = 6
const TYPE_STRING: TypeIndex = 13
const TYPE_FLOAT: TypeIndex = 11
const TYPE_INVALID: TypeIndex = 0

// =============================================================================
// Loop Context (for break/continue)
// =============================================================================

struct LoopContext {
    cond_block: IRBlockIndex,
    exit_block: IRBlockIndex,
}

// =============================================================================
// Lowerer State
// =============================================================================

struct Lowerer {
    // Parser nodes (AST) - reference to parsed AST
    nodes: List<Node>,

    // IR program builder - where we emit IR
    ir_builder: IRProgramBuilder,

    // Current function being lowered
    current_func_name: string,
    has_current_func: bool,

    // String literals collected during lowering
    string_literals: List<string>,

    // Loop context stack for break/continue
    loop_stack: List<LoopContext>,

    // Compile-time constant values
    const_values: Map<string, int>,

    // For-loop counter for unique names
    for_counter: int,

    // Error tracking
    error_count: int,
}

fn lowererInit(nodes: List<Node>) Lowerer {
    return Lowerer{
        .nodes = nodes,
        .ir_builder = irProgramBuilderInit(),
        .current_func_name = "",
        .has_current_func = false,
        .string_literals = new List<string>(),
        .loop_stack = new List<LoopContext>(),
        .const_values = new Map<string, int>(),
        .for_counter = 0,
        .error_count = 0,
    }
}

fn lowererAddStringLiteral(l: *Lowerer, str: string) int {
    var idx: int = len(l.*.string_literals)
    l.*.string_literals.push(str)
    return idx
}

fn lowererPushLoop(l: *Lowerer, cond_block: IRBlockIndex, exit_block: IRBlockIndex) void {
    l.*.loop_stack.push(LoopContext{ .cond_block = cond_block, .exit_block = exit_block })
}

fn lowererPopLoop(l: *Lowerer) void {
    // Pop by removing last element - simplified for bootstrap
    // (Real impl would use a proper pop operation)
}

fn lowererCurrentLoop(l: Lowerer) LoopContext {
    if len(l.loop_stack) == 0 {
        return LoopContext{ .cond_block = ir_null_block, .exit_block = ir_null_block }
    }
    return l.loop_stack.get(len(l.loop_stack) - 1)
}

// =============================================================================
// Statement Lowering Helpers
// =============================================================================

struct IfBlocks {
    then_block: IRBlockIndex,
    else_block: IRBlockIndex,
    merge_block: IRBlockIndex,
    cond_node: IRNodeIndex,
}

struct WhileBlocks {
    cond_block: IRBlockIndex,
    body_block: IRBlockIndex,
    exit_block: IRBlockIndex,
}

struct ForBlocks {
    cond_block: IRBlockIndex,
    body_block: IRBlockIndex,
    incr_block: IRBlockIndex,
    exit_block: IRBlockIndex,
    idx_local: int,
    item_local: int,
    arr_len: int,
}

// =============================================================================
// Declaration Lowering
// =============================================================================

fn lowerVarStmt(l: *Lowerer, fb: *IRFuncBuilder, name: string, type_idx: TypeIndex, value_node: IRNodeIndex, is_mutable: bool, size: int) void {
    var local_idx: int = irFuncBuilderAddLocalWithSize(fb, name, type_idx, is_mutable, size)
    if value_node != ir_null_node {
        var store: IRNode = irNodeInit(Op.store, type_idx, 0, 0)
        store = irNodeWithArg01(store, local_idx, value_node)
        irFuncBuilderEmit(fb, store)
    }
}

fn lowerVarDecl(l: *Lowerer, builder: *IRProgramBuilder, name: string, type_idx: TypeIndex, is_const: bool, span_start: int, span_end: int) void {
    var g: IRGlobal = irGlobalInit(name, type_idx, is_const, span_start, span_end)
    irProgramBuilderAddGlobal(builder, g)
}

fn lowerConstDecl(l: *Lowerer, builder: *IRProgramBuilder, name: string, type_idx: TypeIndex, value: int, span_start: int, span_end: int) void {
    l.*.const_values.set(name, value)
    var g: IRGlobal = irGlobalInit(name, type_idx, true, span_start, span_end)
    irProgramBuilderAddGlobal(builder, g)
}

fn lowerStructDecl(l: *Lowerer, builder: *IRProgramBuilder, name: string, type_idx: TypeIndex, span_start: int, span_end: int) void {
    var sd: IRStructDef = irStructDefInit(name, type_idx, span_start, span_end)
    irProgramBuilderAddStruct(builder, sd)
}

// =============================================================================
// Statement Lowering
// =============================================================================

fn lowerReturn(l: *Lowerer, fb: *IRFuncBuilder, value_node: IRNodeIndex, return_type: TypeIndex, span_start: int, span_end: int) void {
    var ret: IRNode = irNodeInit(Op.ret, return_type, span_start, span_end)
    if value_node != ir_null_node {
        ret = irNodeWithArg0(ret, value_node)
    }
    irFuncBuilderEmit(fb, ret)
}

fn lowerAssign(l: *Lowerer, fb: *IRFuncBuilder, local_idx: int, value_node: IRNodeIndex, type_idx: TypeIndex, span_start: int, span_end: int) void {
    var store: IRNode = irNodeInit(Op.store, type_idx, span_start, span_end)
    store = irNodeWithArg01(store, local_idx, value_node)
    irFuncBuilderEmit(fb, store)
}

fn lowerCompoundAssign(l: *Lowerer, fb: *IRFuncBuilder, local_idx: int, op: Op, rhs: IRNodeIndex, type_idx: TypeIndex, span_start: int, span_end: int) void {
    var load: IRNode = irNodeInit(Op.load, type_idx, span_start, span_end)
    load = irNodeWithArg0(load, local_idx)
    var current_value: IRNodeIndex = irFuncBuilderEmit(fb, load)

    var bin: IRNode = irNodeInit(op, type_idx, span_start, span_end)
    bin = irNodeWithArg01(bin, current_value, rhs)
    var result: IRNodeIndex = irFuncBuilderEmit(fb, bin)

    var store: IRNode = irNodeInit(Op.store, type_idx, span_start, span_end)
    store = irNodeWithArg01(store, local_idx, result)
    irFuncBuilderEmit(fb, store)
}

fn lowerIfSetup(l: *Lowerer, fb: *IRFuncBuilder, cond_node: IRNodeIndex, has_else: bool, span_start: int, span_end: int) IfBlocks {
    var then_block: IRBlockIndex = irFuncBuilderNewBlock(fb, "if.then")
    var merge_block: IRBlockIndex = irFuncBuilderNewBlock(fb, "if.merge")
    var else_block: IRBlockIndex = ir_null_block
    if has_else {
        else_block = irFuncBuilderNewBlock(fb, "if.else")
    }
    return IfBlocks{
        .then_block = then_block,
        .else_block = else_block,
        .merge_block = merge_block,
        .cond_node = cond_node,
    }
}

fn lowerIfEmitBranch(l: *Lowerer, fb: *IRFuncBuilder, blocks: IfBlocks, span_start: int, span_end: int) void {
    var else_target: IRBlockIndex = blocks.else_block
    if else_target == ir_null_block {
        else_target = blocks.merge_block
    }
    irFuncBuilderEmitBranch(fb, blocks.cond_node, blocks.then_block, else_target, span_start, span_end)
}

fn lowerWhileSetup(l: *Lowerer, fb: *IRFuncBuilder, span_start: int, span_end: int) WhileBlocks {
    var cond_block: IRBlockIndex = irFuncBuilderNewBlock(fb, "while.cond")
    var body_block: IRBlockIndex = irFuncBuilderNewBlock(fb, "while.body")
    var exit_block: IRBlockIndex = irFuncBuilderNewBlock(fb, "while.exit")

    lowererPushLoop(l, cond_block, exit_block)
    irFuncBuilderEmitJump(fb, cond_block, span_start, span_end)

    return WhileBlocks{
        .cond_block = cond_block,
        .body_block = body_block,
        .exit_block = exit_block,
    }
}

fn lowerWhileEmitBranch(l: *Lowerer, fb: *IRFuncBuilder, blocks: WhileBlocks, cond_node: IRNodeIndex, span_start: int, span_end: int) void {
    var branch: IRNode = irNodeInit(Op.branch, TYPE_VOID, span_start, span_end)
    branch = irNodeWithArg012(branch, cond_node, blocks.body_block, blocks.exit_block)
    irFuncBuilderEmit(fb, branch)
}

fn lowerWhileFinish(l: *Lowerer, fb: *IRFuncBuilder, blocks: WhileBlocks, span_start: int, span_end: int) void {
    irFuncBuilderEmitJump(fb, blocks.cond_block, span_start, span_end)
    lowererPopLoop(l)
    irFuncBuilderSetBlock(fb, blocks.exit_block)
}

fn lowerBreak(l: *Lowerer, fb: *IRFuncBuilder, span_start: int, span_end: int) void {
    var loop_ctx: LoopContext = lowererCurrentLoop(l.*)
    if loop_ctx.exit_block != ir_null_block {
        irFuncBuilderEmitJump(fb, loop_ctx.exit_block, span_start, span_end)
    }
}

fn lowerContinue(l: *Lowerer, fb: *IRFuncBuilder, span_start: int, span_end: int) void {
    var loop_ctx: LoopContext = lowererCurrentLoop(l.*)
    if loop_ctx.cond_block != ir_null_block {
        irFuncBuilderEmitJump(fb, loop_ctx.cond_block, span_start, span_end)
    }
}

// =============================================================================
// Expression Lowering
// =============================================================================

fn lowerIdentifier(l: *Lowerer, fb: *IRFuncBuilder, name: string, type_idx: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var local_idx: int = irFuncBuilderLookupLocal(fb.*, name)
    if local_idx != -1 {
        var load: IRNode = irNodeInit(Op.load, type_idx, span_start, span_end)
        load = irNodeWithArg0(load, local_idx)
        return irFuncBuilderEmit(fb, load)
    }

    if l.*.const_values.has(name) {
        var value: int = l.*.const_values.get(name)
        var n: IRNode = irNodeInit(Op.const_int, TYPE_INT, span_start, span_end)
        n = irNodeWithAux(n, value)
        return irFuncBuilderEmit(fb, n)
    }

    return ir_null_node
}

fn lowerIntLiteral(l: *Lowerer, fb: *IRFuncBuilder, value: int, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.const_int, TYPE_INT, span_start, span_end)
    n = irNodeWithAux(n, value)
    return irFuncBuilderEmit(fb, n)
}

fn lowerBoolLiteral(l: *Lowerer, fb: *IRFuncBuilder, value: bool, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.const_bool, TYPE_BOOL, span_start, span_end)
    if value {
        n = irNodeWithAux(n, 1)
    } else {
        n = irNodeWithAux(n, 0)
    }
    return irFuncBuilderEmit(fb, n)
}

fn lowerStringLiteral(l: *Lowerer, fb: *IRFuncBuilder, str: string, span_start: int, span_end: int) IRNodeIndex {
    var string_idx: int = lowererAddStringLiteral(l, str)
    var n: IRNode = irNodeInit(Op.const_slice, TYPE_STRING, span_start, span_end)
    n = irNodeWithAux(n, string_idx)
    return irFuncBuilderEmit(fb, n)
}

fn lowerBinary(l: *Lowerer, fb: *IRFuncBuilder, op: Op, left: IRNodeIndex, right: IRNodeIndex, result_type: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(op, result_type, span_start, span_end)
    n = irNodeWithArg01(n, left, right)
    return irFuncBuilderEmit(fb, n)
}

fn lowerUnary(l: *Lowerer, fb: *IRFuncBuilder, op: Op, operand: IRNodeIndex, result_type: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(op, result_type, span_start, span_end)
    n = irNodeWithArg0(n, operand)
    return irFuncBuilderEmit(fb, n)
}

fn lowerCall(l: *Lowerer, fb: *IRFuncBuilder, func_name: string, arg0: IRNodeIndex, arg1: IRNodeIndex, arg2: IRNodeIndex, arg3: IRNodeIndex, num_args: int, return_type: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.call, return_type, span_start, span_end)
    n = irNodeWithAuxStr(n, func_name)
    if num_args >= 1 { n.args0 = arg0 }
    if num_args >= 2 { n.args1 = arg1 }
    if num_args >= 3 { n.args2 = arg2 }
    if num_args >= 4 { n.args3 = arg3 }
    n.args_len = num_args
    return irFuncBuilderEmit(fb, n)
}

fn lowerFieldAccess(l: *Lowerer, fb: *IRFuncBuilder, base_local: int, field_offset: int, field_type: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.field_local, field_type, span_start, span_end)
    n = irNodeWithArg0(n, base_local)
    n = irNodeWithAux(n, field_offset)
    return irFuncBuilderEmit(fb, n)
}

fn lowerFieldValue(l: *Lowerer, fb: *IRFuncBuilder, base_node: IRNodeIndex, field_offset: int, field_type: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.field_value, field_type, span_start, span_end)
    n = irNodeWithArg0(n, base_node)
    n = irNodeWithAux(n, field_offset)
    return irFuncBuilderEmit(fb, n)
}

fn lowerIndex(l: *Lowerer, fb: *IRFuncBuilder, base_local: int, index_node: IRNodeIndex, elem_type: TypeIndex, elem_size: int, is_slice: bool, span_start: int, span_end: int) IRNodeIndex {
    if is_slice {
        var n: IRNode = irNodeInit(Op.slice_index, elem_type, span_start, span_end)
        n = irNodeWithArg01(n, base_local, index_node)
        n = irNodeWithAux(n, elem_size)
        return irFuncBuilderEmit(fb, n)
    } else {
        var n: IRNode = irNodeInit(Op.addr_index, elem_type, span_start, span_end)
        n = irNodeWithArg01(n, base_local, index_node)
        n = irNodeWithAux(n, elem_size)
        return irFuncBuilderEmit(fb, n)
    }
}

fn lowerSliceExpr(l: *Lowerer, fb: *IRFuncBuilder, base_local: int, start_node: IRNodeIndex, end_node: IRNodeIndex, slice_type: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.slice_local, slice_type, span_start, span_end)
    n = irNodeWithArg012(n, base_local, start_node, end_node)
    return irFuncBuilderEmit(fb, n)
}

fn lowerAddrOf(l: *Lowerer, fb: *IRFuncBuilder, local_idx: int, ptr_type: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.addr_local, ptr_type, span_start, span_end)
    n = irNodeWithAux(n, local_idx)
    return irFuncBuilderEmit(fb, n)
}

fn lowerDeref(l: *Lowerer, fb: *IRFuncBuilder, ptr_node: IRNodeIndex, elem_type: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.ptr_load, elem_type, span_start, span_end)
    n = irNodeWithArg0(n, ptr_node)
    return irFuncBuilderEmit(fb, n)
}

fn lowerStructInit(l: *Lowerer, fb: *IRFuncBuilder, struct_type: TypeIndex, struct_size: int, span_start: int, span_end: int) int {
    var temp_local: int = irFuncBuilderAddLocalWithSize(fb, "__struct_tmp", struct_type, false, struct_size)
    return temp_local
}

fn lowerStructInitField(l: *Lowerer, fb: *IRFuncBuilder, local_idx: int, field_offset: int, value_node: IRNodeIndex, field_type: TypeIndex, span_start: int, span_end: int) void {
    var store: IRNode = irNodeInit(Op.store, field_type, span_start, span_end)
    store = irNodeWithArg01(store, local_idx, value_node)
    store = irNodeWithAux(store, field_offset)
    irFuncBuilderEmit(fb, store)
}

fn lowerStructInitFinish(l: *Lowerer, fb: *IRFuncBuilder, local_idx: int, struct_type: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var load: IRNode = irNodeInit(Op.load, struct_type, span_start, span_end)
    load = irNodeWithArg0(load, local_idx)
    return irFuncBuilderEmit(fb, load)
}

fn lowerIfExpr(l: *Lowerer, fb: *IRFuncBuilder, cond: IRNodeIndex, then_val: IRNodeIndex, else_val: IRNodeIndex, result_type: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.select, result_type, span_start, span_end)
    n = irNodeWithArg012(n, cond, then_val, else_val)
    return irFuncBuilderEmit(fb, n)
}

// =============================================================================
// Map/List Operations
// =============================================================================

fn lowerMapNew(l: *Lowerer, fb: *IRFuncBuilder, map_type: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.map_new, map_type, span_start, span_end)
    return irFuncBuilderEmit(fb, n)
}

fn lowerMapSet(l: *Lowerer, fb: *IRFuncBuilder, map_handle: IRNodeIndex, key_node: IRNodeIndex, value_node: IRNodeIndex, key_type: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.map_set, TYPE_VOID, span_start, span_end)
    n = irNodeWithArg012(n, map_handle, key_node, value_node)
    irNodeSetArg(&n, 3, key_type)
    n.args_len = 4
    return irFuncBuilderEmit(fb, n)
}

fn lowerMapGet(l: *Lowerer, fb: *IRFuncBuilder, map_handle: IRNodeIndex, key_node: IRNodeIndex, value_type: TypeIndex, key_type: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.map_get, value_type, span_start, span_end)
    n = irNodeWithArg01(n, map_handle, key_node)
    n = irNodeWithAux(n, key_type)
    return irFuncBuilderEmit(fb, n)
}

fn lowerMapHas(l: *Lowerer, fb: *IRFuncBuilder, map_handle: IRNodeIndex, key_node: IRNodeIndex, key_type: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.map_has, TYPE_BOOL, span_start, span_end)
    n = irNodeWithArg01(n, map_handle, key_node)
    n = irNodeWithAux(n, key_type)
    return irFuncBuilderEmit(fb, n)
}

fn lowerMapSize(l: *Lowerer, fb: *IRFuncBuilder, map_handle: IRNodeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.map_size, TYPE_INT, span_start, span_end)
    n = irNodeWithArg0(n, map_handle)
    return irFuncBuilderEmit(fb, n)
}

fn lowerListNew(l: *Lowerer, fb: *IRFuncBuilder, list_type: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.list_new, list_type, span_start, span_end)
    return irFuncBuilderEmit(fb, n)
}

fn lowerListPush(l: *Lowerer, fb: *IRFuncBuilder, list_handle: IRNodeIndex, value_node: IRNodeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.list_push, TYPE_VOID, span_start, span_end)
    n = irNodeWithArg01(n, list_handle, value_node)
    return irFuncBuilderEmit(fb, n)
}

fn lowerListGet(l: *Lowerer, fb: *IRFuncBuilder, list_handle: IRNodeIndex, index_node: IRNodeIndex, elem_type: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.list_get, elem_type, span_start, span_end)
    n = irNodeWithArg01(n, list_handle, index_node)
    return irFuncBuilderEmit(fb, n)
}

fn lowerListLen(l: *Lowerer, fb: *IRFuncBuilder, list_handle: IRNodeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.list_len, TYPE_INT, span_start, span_end)
    n = irNodeWithArg0(n, list_handle)
    return irFuncBuilderEmit(fb, n)
}

// =============================================================================
// Union Operations
// =============================================================================

fn lowerUnionInit(l: *Lowerer, fb: *IRFuncBuilder, union_type: TypeIndex, variant_idx: int, payload_node: IRNodeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.union_init, union_type, span_start, span_end)
    n = irNodeWithAux(n, variant_idx)
    if payload_node != ir_null_node {
        n = irNodeWithArg0(n, payload_node)
    }
    return irFuncBuilderEmit(fb, n)
}

fn lowerUnionTag(l: *Lowerer, fb: *IRFuncBuilder, union_node: IRNodeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.union_tag, TYPE_U8, span_start, span_end)
    n = irNodeWithArg0(n, union_node)
    return irFuncBuilderEmit(fb, n)
}

fn lowerUnionPayload(l: *Lowerer, fb: *IRFuncBuilder, union_node: IRNodeIndex, variant_idx: int, payload_type: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.union_payload, payload_type, span_start, span_end)
    n = irNodeWithArg0(n, union_node)
    n = irNodeWithAux(n, variant_idx)
    return irFuncBuilderEmit(fb, n)
}

// =============================================================================
// Builtin Functions
// =============================================================================

fn lowerLenArray(l: *Lowerer, fb: *IRFuncBuilder, arr_len: int, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.const_int, TYPE_INT, span_start, span_end)
    n = irNodeWithAux(n, arr_len)
    return irFuncBuilderEmit(fb, n)
}

fn lowerLenSlice(l: *Lowerer, fb: *IRFuncBuilder, slice_local: int, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.field, TYPE_INT, span_start, span_end)
    n = irNodeWithArg0(n, slice_local)
    n = irNodeWithAux(n, 8)
    return irFuncBuilderEmit(fb, n)
}

fn lowerMaxInt(l: *Lowerer, fb: *IRFuncBuilder, type_idx: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var max_value: int = 0
    if type_idx == 2 { max_value = 127 }
    if type_idx == 3 { max_value = 32767 }
    if type_idx == 4 { max_value = 2147483647 }
    if type_idx == 5 { max_value = @maxInt(i64) }
    if type_idx == 6 { max_value = 255 }
    if type_idx == 7 { max_value = 65535 }
    if type_idx == 8 { max_value = 4294967295 }
    var n: IRNode = irNodeInit(Op.const_int, TYPE_I64, span_start, span_end)
    n = irNodeWithAux(n, max_value)
    return irFuncBuilderEmit(fb, n)
}

fn lowerMinInt(l: *Lowerer, fb: *IRFuncBuilder, type_idx: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var min_value: int = 0
    if type_idx == 2 { min_value = -128 }
    if type_idx == 3 { min_value = -32768 }
    if type_idx == 4 { min_value = -2147483648 }
    if type_idx == 5 { min_value = @minInt(i64) }
    var n: IRNode = irNodeInit(Op.const_int, TYPE_I64, span_start, span_end)
    n = irNodeWithAux(n, min_value)
    return irFuncBuilderEmit(fb, n)
}

fn lowerPrint(l: *Lowerer, fb: *IRFuncBuilder, arg_node: IRNodeIndex, is_println: bool, span_start: int, span_end: int) IRNodeIndex {
    var func_name: string = "print"
    if is_println {
        func_name = "println"
    }
    var n: IRNode = irNodeInit(Op.call, TYPE_VOID, span_start, span_end)
    n = irNodeWithArg0(n, arg_node)
    n = irNodeWithAuxStr(n, func_name)
    n.args_len = 1
    return irFuncBuilderEmit(fb, n)
}

// =============================================================================
// Pointer Operations
// =============================================================================

fn lowerPtrStore(l: *Lowerer, fb: *IRFuncBuilder, ptr_node: IRNodeIndex, value_node: IRNodeIndex, elem_type: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.ptr_store, elem_type, span_start, span_end)
    n = irNodeWithArg01(n, ptr_node, value_node)
    return irFuncBuilderEmit(fb, n)
}

fn lowerPtrField(l: *Lowerer, fb: *IRFuncBuilder, local_idx: int, field_offset: int, field_type: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.ptr_field, field_type, span_start, span_end)
    n = irNodeWithArg0(n, local_idx)
    n = irNodeWithAux(n, field_offset)
    return irFuncBuilderEmit(fb, n)
}

fn lowerPtrFieldStore(l: *Lowerer, fb: *IRFuncBuilder, local_idx: int, field_offset: int, value_node: IRNodeIndex, field_type: TypeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.ptr_field_store, field_type, span_start, span_end)
    n = irNodeWithArg01(n, local_idx, value_node)
    n = irNodeWithAux(n, field_offset)
    return irFuncBuilderEmit(fb, n)
}

fn lowerStrConcat(l: *Lowerer, fb: *IRFuncBuilder, left: IRNodeIndex, right: IRNodeIndex, span_start: int, span_end: int) IRNodeIndex {
    var n: IRNode = irNodeInit(Op.str_concat, TYPE_STRING, span_start, span_end)
    n = irNodeWithArg01(n, left, right)
    return irFuncBuilderEmit(fb, n)
}

// =============================================================================
// AST Node Accessors
// =============================================================================

fn lowererGetNode(l: Lowerer, idx: NodeIndex) Node {
    return l.nodes.get(idx)
}

// =============================================================================
// Helper Functions
// =============================================================================

fn parseIntLiteral(text: string) int {
    var result: int = 0
    var i: int = 0
    var negative: bool = false

    // Check for negative
    if len(text) > 0 and text[0] == 45 {  // '-'
        negative = true
        i = 1
    }

    while i < len(text) {
        var c: int = text[i]
        if c >= 48 and c <= 57 {  // '0'-'9'
            result = result * 10 + (c - 48)
        }
        i = i + 1
    }

    if negative {
        result = 0 - result
    }

    return result
}

fn tokenToIROp(tok: Token) Op {
    if tok == Token.plus { return Op.add }
    if tok == Token.minus { return Op.sub }
    if tok == Token.star { return Op.mul }
    if tok == Token.slash { return Op.div }
    if tok == Token.percent { return Op.mod }
    if tok == Token.equal_equal { return Op.eq }
    if tok == Token.bang_equal { return Op.ne }
    if tok == Token.less { return Op.lt }
    if tok == Token.less_equal { return Op.le }
    if tok == Token.greater { return Op.gt }
    if tok == Token.greater_equal { return Op.ge }
    if tok == Token.kw_and { return Op.op_and }
    if tok == Token.kw_or { return Op.op_or }
    return Op.nop
}

// =============================================================================
// Expression Lowering (AST to IR)
// =============================================================================

fn lowerExprNode(l: *Lowerer, fb: *IRFuncBuilder, node_idx: NodeIndex) NodeIndex {
    if node_idx == null_node {
        return null_node
    }

    var node: Node = l.*.nodes.get(node_idx)
    var span_start: int = node.span.start.offset
    var span_end: int = node.span.end.offset
    var tag: NodeTag = node.tag

    if tag == NodeTag.int_literal {
        return lowerIntLiteralExpr(l, fb, node, span_start, span_end)
    }
    if tag == NodeTag.bool_literal {
        return lowerBoolLiteralExpr(l, fb, node, span_start, span_end)
    }
    if tag == NodeTag.string_literal {
        return lowerStringLiteralExpr(l, fb, node, span_start, span_end)
    }
    if tag == NodeTag.identifier {
        return lowerIdentifierExpr(l, fb, node, span_start, span_end)
    }
    if tag == NodeTag.binary_expr {
        return lowerBinaryExpr(l, fb, node, span_start, span_end)
    }
    if tag == NodeTag.unary_expr {
        return lowerUnaryExpr(l, fb, node, span_start, span_end)
    }
    if tag == NodeTag.call_expr {
        return lowerCallExpr(l, fb, node, span_start, span_end)
    }
    if tag == NodeTag.paren_expr {
        return lowerExprNode(l, fb, node.left)
    }
    if tag == NodeTag.struct_init {
        // TODO: Implement struct init lowering
        // For now, struct init requires type info (field offsets)
        // Parser now captures field inits in node.args (BUG-005 fix)
        println("DEBUG: struct_init lowering not yet implemented")
        return null_node
    }
    return null_node
}

fn lowerIntLiteralExpr(l: *Lowerer, fb: *IRFuncBuilder, node: Node, span_start: int, span_end: int) NodeIndex {
    var value: int = parseIntLiteral(node.text)
    return irFuncBuilderEmitConstInt(fb, value, TYPE_INT, span_start, span_end)
}

fn lowerBoolLiteralExpr(l: *Lowerer, fb: *IRFuncBuilder, node: Node, span_start: int, span_end: int) NodeIndex {
    var value: bool = node.text == "true"
    return irFuncBuilderEmitConstBool(fb, value, span_start, span_end)
}

fn lowerStringLiteralExpr(l: *Lowerer, fb: *IRFuncBuilder, node: Node, span_start: int, span_end: int) NodeIndex {
    var idx: int = len(l.*.string_literals)
    l.*.string_literals.push(node.text)
    return irFuncBuilderEmitConstSlice(fb, idx, TYPE_STRING, span_start, span_end)
}

fn lowerIdentifierExpr(l: *Lowerer, fb: *IRFuncBuilder, node: Node, span_start: int, span_end: int) NodeIndex {
    var local_idx: int = irFuncBuilderLookupLocal(fb.*, node.name)
    if local_idx >= 0 {
        return irFuncBuilderEmitLocalLoad(fb, local_idx, TYPE_INT, span_start, span_end)
    }
    // Not found - error
    l.*.error_count = l.*.error_count + 1
    return null_node
}

fn lowerBinaryExpr(l: *Lowerer, fb: *IRFuncBuilder, node: Node, span_start: int, span_end: int) NodeIndex {
    var left: NodeIndex = lowerExprNode(l, fb, node.left)
    var right: NodeIndex = lowerExprNode(l, fb, node.right)
    var ir_op: Op = tokenToIROp(node.op)
    return irFuncBuilderEmitBinary(fb, ir_op, left, right, TYPE_INT, span_start, span_end)
}

fn lowerUnaryExpr(l: *Lowerer, fb: *IRFuncBuilder, node: Node, span_start: int, span_end: int) NodeIndex {
    var operand: NodeIndex = lowerExprNode(l, fb, node.left)
    var ir_op: Op = Op.nop
    var tok: Token = node.op
    if tok == Token.minus { ir_op = Op.neg }
    if tok == Token.bang { ir_op = Op.op_not }
    return irFuncBuilderEmitUnary(fb, ir_op, operand, TYPE_INT, span_start, span_end)
}

fn lowerCallExpr(l: *Lowerer, fb: *IRFuncBuilder, node: Node, span_start: int, span_end: int) NodeIndex {
    var callee_node: Node = l.*.nodes.get(node.left)
    var func_name: string = callee_node.name

    var arg0: NodeIndex = null_node
    var arg1: NodeIndex = null_node
    var arg2: NodeIndex = null_node
    var arg3: NodeIndex = null_node
    var num_args: int = len(node.args)

    if num_args > 0 {
        arg0 = lowerExprNode(l, fb, node.args.get(0))
    }
    if num_args > 1 {
        arg1 = lowerExprNode(l, fb, node.args.get(1))
    }
    if num_args > 2 {
        arg2 = lowerExprNode(l, fb, node.args.get(2))
    }
    if num_args > 3 {
        arg3 = lowerExprNode(l, fb, node.args.get(3))
    }

    var n: IRNode = irNodeInit(Op.call, TYPE_INT, span_start, span_end)
    n.aux_str = func_name
    if num_args > 0 { n = irNodeWithArg0(n, arg0) }
    if num_args > 1 { n.args1 = arg1; n.args_len = 2 }
    if num_args > 2 { n.args2 = arg2; n.args_len = 3 }
    if num_args > 3 { n.args3 = arg3; n.args_len = 4 }

    return irFuncBuilderEmit(fb, n)
}

// =============================================================================
// Statement Lowering (AST to IR)
// =============================================================================

fn lowerStmtNode(l: *Lowerer, fb: *IRFuncBuilder, node_idx: NodeIndex) void {
    if node_idx == null_node {
        return
    }

    var node: Node = l.*.nodes.get(node_idx)
    var span_start: int = node.span.start.offset
    var span_end: int = node.span.end.offset
    var tag: NodeTag = node.tag

    if tag == NodeTag.return_stmt {
        lowerReturnStmt(l, fb, node, span_start, span_end)
    } else if tag == NodeTag.var_stmt {
        lowerVarStmtAST(l, fb, node, span_start, span_end)
    } else if tag == NodeTag.assign_stmt {
        lowerAssignStmt(l, fb, node, span_start, span_end)
    } else if tag == NodeTag.if_stmt {
        lowerIfStmt(l, fb, node, span_start, span_end)
    } else if tag == NodeTag.while_stmt {
        lowerWhileStmt(l, fb, node, span_start, span_end)
    } else if tag == NodeTag.block_stmt {
        lowerBlockStmt(l, fb, node)
    } else if tag == NodeTag.expr_stmt {
        lowerExprStmt(l, fb, node)
    }
}

fn lowerReturnStmt(l: *Lowerer, fb: *IRFuncBuilder, node: Node, span_start: int, span_end: int) void {
    var value: NodeIndex = null_node
    if node.left != null_node {
        value = lowerExprNode(l, fb, node.left)
    }
    irFuncBuilderEmitReturn(fb, value, span_start, span_end)
}

fn lowerVarStmtAST(l: *Lowerer, fb: *IRFuncBuilder, node: Node, span_start: int, span_end: int) void {
    var local_idx: int = irFuncBuilderAddLocal(fb, node.name, TYPE_INT, true)
    // Parser stores initializer in node.left
    if node.left != null_node {
        var init_val: NodeIndex = lowerExprNode(l, fb, node.left)
        irFuncBuilderEmitLocalStore(fb, local_idx, init_val, TYPE_INT, span_start, span_end)
    }
}

fn lowerAssignStmt(l: *Lowerer, fb: *IRFuncBuilder, node: Node, span_start: int, span_end: int) void {
    var target_node: Node = l.*.nodes.get(node.left)
    var local_idx: int = irFuncBuilderLookupLocal(fb.*, target_node.name)
    if local_idx >= 0 {
        var value: NodeIndex = lowerExprNode(l, fb, node.right)
        irFuncBuilderEmitLocalStore(fb, local_idx, value, TYPE_INT, span_start, span_end)
    }
}

fn lowerIfStmt(l: *Lowerer, fb: *IRFuncBuilder, node: Node, span_start: int, span_end: int) void {
    var has_else: bool = node.else_body != null_node
    var cond: NodeIndex = lowerExprNode(l, fb, node.cond)

    var then_block: IRBlockIndex = irFuncBuilderNewBlock(fb, "then")
    var else_block: IRBlockIndex = irFuncBuilderNewBlock(fb, "else")
    var merge_block: IRBlockIndex = irFuncBuilderNewBlock(fb, "merge")

    irFuncBuilderEmitBranch(fb, cond, then_block, else_block, span_start, span_end)

    irFuncBuilderSetBlock(fb, then_block)
    lowerStmtNode(l, fb, node.body)
    irFuncBuilderEmitJump(fb, merge_block, span_start, span_end)

    irFuncBuilderSetBlock(fb, else_block)
    if has_else {
        lowerStmtNode(l, fb, node.else_body)
    }
    irFuncBuilderEmitJump(fb, merge_block, span_start, span_end)

    irFuncBuilderSetBlock(fb, merge_block)
}

fn lowerWhileStmt(l: *Lowerer, fb: *IRFuncBuilder, node: Node, span_start: int, span_end: int) void {
    var cond_block: IRBlockIndex = irFuncBuilderNewBlock(fb, "while.cond")
    var body_block: IRBlockIndex = irFuncBuilderNewBlock(fb, "while.body")
    var exit_block: IRBlockIndex = irFuncBuilderNewBlock(fb, "while.exit")

    irFuncBuilderEmitJump(fb, cond_block, span_start, span_end)

    irFuncBuilderSetBlock(fb, cond_block)
    var cond: NodeIndex = lowerExprNode(l, fb, node.cond)
    irFuncBuilderEmitBranch(fb, cond, body_block, exit_block, span_start, span_end)

    irFuncBuilderSetBlock(fb, body_block)
    lowerStmtNode(l, fb, node.body)
    irFuncBuilderEmitJump(fb, cond_block, span_start, span_end)

    irFuncBuilderSetBlock(fb, exit_block)
}

fn lowerBlockStmt(l: *Lowerer, fb: *IRFuncBuilder, node: Node) void {
    var arg_count: int = len(node.args)
    var i: int = 0
    while i < arg_count {
        lowerStmtNode(l, fb, node.args.get(i))
        i = i + 1
    }
}

fn lowerExprStmt(l: *Lowerer, fb: *IRFuncBuilder, node: Node) void {
    lowerExprNode(l, fb, node.left)
}

// =============================================================================
// Function Declaration Lowering
// =============================================================================

fn lowerFnDeclNode(l: *Lowerer, node_idx: NodeIndex) void {
    var node: Node = l.*.nodes.get(node_idx)
    var span_start: int = node.span.start.offset
    var span_end: int = node.span.end.offset

    var fb: IRFuncBuilder = irFuncBuilderInit(node.name, 0, TYPE_INT, span_start, span_end)

    var entry_block: IRBlockIndex = irFuncBuilderNewBlock(&fb, "entry")
    irFuncBuilderSetBlock(&fb, entry_block)

    if node.body != null_node {
        lowerStmtNode(l, &fb, node.body)
    }

    var func: IRFunc = irFuncBuilderBuild(fb)
    l.*.ir_builder.ir.funcs.push(func)
}

// =============================================================================
// Main Program Lowering Entry Point
// =============================================================================

fn lowerProgram(l: *Lowerer) void {
    var i: int = 0
    var count: int = len(l.*.nodes)

    while i < count {
        var node: Node = l.*.nodes.get(i)
        var tag: NodeTag = node.tag

        if tag == NodeTag.fn_decl {
            lowerFnDeclNode(l, i)
        }
        // TODO: Handle struct_decl, enum_decl, etc.

        i = i + 1
    }
}

// =============================================================================
// Simple Test
// =============================================================================

fn test_lower() int {
    // Test lowerer initialization
    var empty_nodes: List<Node> = new List<Node>()
    var l: Lowerer = lowererInit(empty_nodes)
    if l.for_counter != 0 {
        return 1
    }
    if l.error_count != 0 {
        return 100
    }

    // Test string literal addition
    var str_idx: int = lowererAddStringLiteral(&l, "hello")
    if str_idx != 0 {
        return 2
    }
    var str_idx2: int = lowererAddStringLiteral(&l, "world")
    if str_idx2 != 1 {
        return 3
    }

    // Test loop context
    lowererPushLoop(&l, 10, 20)
    var ctx: LoopContext = lowererCurrentLoop(l)
    if ctx.cond_block != 10 {
        return 4
    }
    if ctx.exit_block != 20 {
        return 5
    }

    // Test const values
    l.const_values.set("MAX", 100)
    if not l.const_values.has("MAX") {
        return 6
    }
    if l.const_values.get("MAX") != 100 {
        return 7
    }

    // Test Node creation
    var n: IRNode = irNodeInit(Op.const_int, TYPE_INT, 0, 10)
    n = irNodeWithAux(n, 42)
    if n.op != Op.const_int {
        return 8
    }
    if n.aux != 42 {
        return 9
    }

    // Test nodeWithArg functions
    var n2: IRNode = irNodeInit(Op.add, TYPE_INT, 0, 10)
    n2 = irNodeWithArg01(n2, 10, 20)
    if irNodeGetArg(n2, 0) != 10 {
        return 10
    }
    if irNodeGetArg(n2, 1) != 20 {
        return 11
    }

    // Test Local creation
    var local: IRLocal = irLocalInit("x", TYPE_INT, 0, true)
    if local.name != "x" {
        return 12
    }
    if not local.mutable {
        return 13
    }

    // Test irLocalInitWithSize
    var local2: IRLocal = irLocalInitWithSize("y", TYPE_INT, 1, false, 16)
    if local2.size != 16 {
        return 14
    }

    // Test Block creation
    var block: IRBlock = irBlockInit(0)
    if block.index != 0 {
        return 15
    }

    // Test Global creation
    var g: IRGlobal = irGlobalInit("MAX_VALUE", TYPE_INT, true, 0, 10)
    if g.name != "MAX_VALUE" {
        return 16
    }
    if not g.is_const {
        return 17
    }

    // Test StructDef creation
    var sd: IRStructDef = irStructDefInit("Point", 100, 0, 30)
    if sd.name != "Point" {
        return 18
    }

    // Test IfBlocks struct
    var if_blocks: IfBlocks = IfBlocks{
        .then_block = 1,
        .else_block = 2,
        .merge_block = 3,
        .cond_node = 0,
    }
    if if_blocks.then_block != 1 {
        return 19
    }

    // Test WhileBlocks struct
    var while_blocks: WhileBlocks = WhileBlocks{
        .cond_block = 10,
        .body_block = 11,
        .exit_block = 12,
    }
    if while_blocks.cond_block != 10 {
        return 20
    }

    // All tests pass
    return 42
}
